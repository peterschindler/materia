var materia =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/brillouinzoneviewer.js":
/*!***************************************!*\
  !*** ./src/js/brillouinzoneviewer.js ***!
  \***************************************/
/*! exports provided: BrillouinZoneViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BrillouinZoneViewer\", function() { return BrillouinZoneViewer; });\n/* harmony import */ var _viewer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./viewer */ \"./src/js/viewer.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);\n\n\n/*\n * A 3D visualizer for the Brillouin Zone and the k-point path within it.\n */\nclass BrillouinZoneViewer extends _viewer__WEBPACK_IMPORTED_MODULE_0__[\"Viewer\"] {\n    /*\n     * Overrides the implementation from the base class, as we need two scenes:\n     * one for the BZ mesh and another for the information that is laid on top.\n     */\n    setupScenes() {\n        this.scenes = [];\n        this.sceneZone = new three__WEBPACK_IMPORTED_MODULE_1__[\"Scene\"]();\n        this.scenes.push(this.sceneZone);\n        this.sceneInfo = new three__WEBPACK_IMPORTED_MODULE_1__[\"Scene\"]();\n        this.scenes.push(this.sceneInfo);\n        //this.setupControlVariables(10, 2.5, 50);\n    }\n    setupLights() {\n        // White directional light shining from the top.\n        let directionalLight = new three__WEBPACK_IMPORTED_MODULE_1__[\"DirectionalLight\"](0xffffff, 0.05);\n        directionalLight.position.set(0, 0, 30);\n        this.sceneZone.add(directionalLight);\n        // White ambient light.\n        let ambientLight = new three__WEBPACK_IMPORTED_MODULE_1__[\"AmbientLight\"](0x404040, 4.1); // soft white light\n        this.sceneZone.add(ambientLight);\n    }\n    /**\n     * Used to initialize the viewer with data.\n     *\n     * @data {object} Data that describes the Brillouin Zone.\n     */\n    load(data) {\n        // Add the Brillouin zone and the k-point path\n        let vertices = data[\"vertices\"];\n        let faces = data[\"faces\"];\n        let basis = data[\"basis\"];\n        let segments = data[\"segments\"];\n        let labels = data[\"labels\"];\n        this.basis = data[\"basis\"];\n        if (!vertices || !faces || !basis || !segments) {\n            console.log(\"The data given for the Brillouin zone viewer is incomplete.\");\n            return false;\n        }\n        else {\n            if (!labels) {\n                console.log(\"No labels provided for Brillouin zone viewer.\");\n            }\n            this.createBrillouinZone(vertices, faces, basis, segments, labels);\n        }\n        this.setupInitialView();\n        return true;\n    }\n    /**\n     * Used to setup the visualization according to the given options.\n     */\n    setOptions(opt) {\n        // The default settings object\n        let options = {\n            controls: {\n                rotateSpeed: 40,\n                enablePan: false\n            },\n            view: {\n                fitMargin: 0.01,\n            },\n            segments: {\n                color: \"#E56400\"\n            },\n            labels: {\n                font: \"Arial\",\n                size: 0.7,\n                color: \"#E56400\",\n            },\n            renderer: {\n                backgroundColor: [\"#ffffff\", 1]\n            }\n        };\n        this.fillOptions(opt, options);\n        // Handle base class settings\n        super.setOptions(options);\n    }\n    setupInitialView() {\n        //Rotate the scene so that the first basis vector is pointing up.\n        let yAxis = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 1, 0);\n        let xAxis = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](1, 0, 0);\n        let zAxis = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 0, 1);\n        let direction = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().fromArray(this.basis[0]);\n        let quaternion = new three__WEBPACK_IMPORTED_MODULE_1__[\"Quaternion\"]().setFromUnitVectors(yAxis, direction.clone().normalize());\n        quaternion.conjugate();\n        this.info.quaternion.copy(quaternion);\n        this.zone.quaternion.copy(quaternion);\n        // Rotate the scene so that the segments are shown properly\n        this.info.updateMatrixWorld(); // The positions are not otherwise updated properly\n        this.zone.updateMatrixWorld();\n        let average = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]();\n        let nLabelPoints = this.labelPoints.length;\n        for (let iSegmentPoint = 0; iSegmentPoint < nLabelPoints; ++iSegmentPoint) {\n            let segmentPoint = this.labelPoints[iSegmentPoint];\n            average.add(segmentPoint.getWorldPosition(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]()));\n        }\n        average.multiplyScalar(1 / nLabelPoints);\n        average.y = 0;\n        let segmentQ = new three__WEBPACK_IMPORTED_MODULE_1__[\"Quaternion\"]().setFromUnitVectors(zAxis, average.clone().normalize());\n        segmentQ.conjugate();\n        this.info.quaternion.premultiply(segmentQ);\n        this.zone.quaternion.premultiply(segmentQ);\n        // Rotate the zone so that it is shown from slightly above\n        let qX = new three__WEBPACK_IMPORTED_MODULE_1__[\"Quaternion\"]();\n        qX.setFromAxisAngle(xAxis, Math.PI / 8);\n        this.info.quaternion.premultiply(qX);\n        this.zone.quaternion.premultiply(qX);\n    }\n    /*\n     * Used to create the representation for the first Brillouin Zone.\n     */\n    createBrillouinZone(vertices, faces, basis, segments, labels) {\n        this.zone = new three__WEBPACK_IMPORTED_MODULE_1__[\"Object3D\"]();\n        this.zone.name = \"zone\";\n        this.sceneZone.add(this.zone);\n        this.info = new three__WEBPACK_IMPORTED_MODULE_1__[\"Object3D\"]();\n        this.info.name = \"info\";\n        this.sceneInfo.add(this.info);\n        let bzGeometry = new three__WEBPACK_IMPORTED_MODULE_1__[\"Geometry\"]();\n        let bzMaterial = new three__WEBPACK_IMPORTED_MODULE_1__[\"MeshLambertMaterial\"]({\n            color: 0xeeeeee,\n            side: three__WEBPACK_IMPORTED_MODULE_1__[\"DoubleSide\"],\n            transparent: true,\n            opacity: 0.8\n        });\n        let lineMaterial = new three__WEBPACK_IMPORTED_MODULE_1__[\"LineBasicMaterial\"]({\n            color: 0x3333333,\n            linewidth: 2,\n        });\n        // Create vertices\n        for (let iVertex = 0; iVertex < vertices.length; ++iVertex) {\n            let vertex = vertices[iVertex];\n            bzGeometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().fromArray(vertex).multiplyScalar(1E-10));\n        }\n        // Create faces\n        let faceMap = {};\n        for (let iFace = 0; iFace < faces.length; ++iFace) {\n            let faceIndices = faces[iFace];\n            let nPoints = faceIndices.length;\n            for (let iPoint = 0; iPoint < nPoints; ++iPoint) {\n                // Create edges\n                let firstIndex = faceIndices[iPoint];\n                let secondIndex = faceIndices[(iPoint + 1) % nPoints];\n                let key1 = [firstIndex, secondIndex];\n                let key2 = [secondIndex, firstIndex];\n                if (!faceMap.hasOwnProperty(key1.toString()) && !faceMap.hasOwnProperty(key2.toString())) {\n                    faceMap[key1.toString()] = true;\n                    faceMap[key2.toString()] = true;\n                    let lineGeometry = new three__WEBPACK_IMPORTED_MODULE_1__[\"Geometry\"]();\n                    lineGeometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().fromArray(vertices[firstIndex]).multiplyScalar(1E-10), new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().fromArray(vertices[secondIndex]).multiplyScalar(1E-10));\n                    let line = new three__WEBPACK_IMPORTED_MODULE_1__[\"Line\"](lineGeometry, lineMaterial);\n                    this.zone.add(line);\n                }\n                // Create surfaces\n                if (iPoint < nPoints - 2) {\n                    let face = new three__WEBPACK_IMPORTED_MODULE_1__[\"Face3\"](faceIndices[0], faceIndices[(iPoint + 1) % nPoints], faceIndices[(iPoint + 2) % nPoints]\n                    //normal\n                    );\n                    bzGeometry.faces.push(face);\n                }\n            }\n        }\n        // Compute normals that are needed for shading the surface\n        bzGeometry.computeFaceNormals();\n        // Create the reciprocal space axes\n        let createAxisLabel = (position, label) => {\n            // Configure canvas\n            let canvas = document.createElement('canvas');\n            let size = 256;\n            canvas.width = size;\n            canvas.height = size;\n            let ctx = canvas.getContext('2d');\n            // Draw label\n            ctx.fillStyle = \"#000000\";\n            ctx.font = \"90px \" + this.options.labels.font;\n            ctx.textAlign = \"center\";\n            ctx.fillText(label, size / 2, size / 2);\n            let texture = new three__WEBPACK_IMPORTED_MODULE_1__[\"Texture\"](canvas);\n            texture.needsUpdate = true;\n            let material = new three__WEBPACK_IMPORTED_MODULE_1__[\"SpriteMaterial\"]({ map: texture });\n            let sprite = new three__WEBPACK_IMPORTED_MODULE_1__[\"Sprite\"](material);\n            sprite.position.copy(position);\n            let scale = 1 / 11;\n            sprite.scale.set(scale, scale, 1);\n            return sprite;\n        };\n        for (let iBasis = 0; iBasis < 3; ++iBasis) {\n            let length = 0.7;\n            let basisVector = basis[iBasis];\n            let origin = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 0, 0);\n            let dir = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]()\n                .fromArray(basisVector)\n                .multiplyScalar(1E-10)\n                .multiplyScalar(length);\n            // Add a dashed line\n            let lineGeometry = new three__WEBPACK_IMPORTED_MODULE_1__[\"Geometry\"]();\n            lineGeometry.vertices.push(origin, dir);\n            let lineMaterial = new three__WEBPACK_IMPORTED_MODULE_1__[\"LineDashedMaterial\"]({\n                color: 0x000000,\n                linewidth: 0.1,\n                dashSize: 0.005,\n                gapSize: 0.005\n            });\n            let line = new three__WEBPACK_IMPORTED_MODULE_1__[\"Line\"](lineGeometry, lineMaterial);\n            line.computeLineDistances();\n            this.info.add(line);\n            // Add an axis label\n            let textOffset = 0.020;\n            let textPos = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]()\n                .copy(dir)\n                .multiplyScalar(1 + textOffset / dir.length());\n            let axisLabel;\n            switch (iBasis) {\n                case 0:\n                    axisLabel = \"b₁\";\n                    break;\n                case 1:\n                    axisLabel = \"b₂\";\n                    break;\n                case 2:\n                    axisLabel = \"b₃\";\n                    break;\n            }\n            axisLabel = createAxisLabel(textPos, axisLabel);\n            this.info.add(axisLabel);\n            // Add axis arrow\n            let arrowGeometry = new three__WEBPACK_IMPORTED_MODULE_1__[\"CylinderGeometry\"](0, 0.003, 0.012, 12);\n            let arrowMaterial = new three__WEBPACK_IMPORTED_MODULE_1__[\"MeshBasicMaterial\"]({ color: 0x000000 });\n            let arrow = new three__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"](arrowGeometry, arrowMaterial);\n            arrow.position.copy(dir);\n            arrow.lookAt(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]());\n            arrow.rotateX(-Math.PI / 2);\n            this.info.add(arrow);\n        }\n        /*\n         * For creating high symmetry points.\n         */\n        let merged = [].concat.apply([], basis);\n        let basisMatrix = new three__WEBPACK_IMPORTED_MODULE_1__[\"Matrix3\"]().fromArray(merged);\n        let labelMap = {};\n        let labelPositions = [];\n        let generateSymmPoint = (position, label) => {\n            // Configure canvas\n            let canvas = document.createElement('canvas');\n            let size = 256;\n            canvas.width = size;\n            canvas.height = size;\n            let ctx = canvas.getContext('2d');\n            // Draw circle\n            ctx.beginPath();\n            ctx.arc(size / 2, size / 2, size / 15, 0, 2 * Math.PI);\n            ctx.fillStyle = this.options.segments.color;\n            ctx.fill();\n            // Draw label\n            ctx.fillStyle = \"#000000\";\n            ctx.font = \"100px \" + this.options.labels.font;\n            ctx.textAlign = \"center\";\n            ctx.fillText(label, canvas.width / 2, 80);\n            let texture = new three__WEBPACK_IMPORTED_MODULE_1__[\"Texture\"](canvas);\n            texture.needsUpdate = true;\n            let material = new three__WEBPACK_IMPORTED_MODULE_1__[\"SpriteMaterial\"]({ map: texture });\n            let sprite = new three__WEBPACK_IMPORTED_MODULE_1__[\"Sprite\"](material);\n            sprite.position.copy(position);\n            let scale = 1 / 15;\n            sprite.scale.set(scale, scale, 1);\n            return sprite;\n        };\n        // Create the k-point path from the given segments. Currently assumes\n        // that the segments are linear and the segment path is determined by\n        // the start and end point.\n        let kpathMaterial = new three__WEBPACK_IMPORTED_MODULE_1__[\"LineBasicMaterial\"]({\n            color: this.options.segments.color,\n            linewidth: 3,\n        });\n        let kpathGeometry = new three__WEBPACK_IMPORTED_MODULE_1__[\"Geometry\"]();\n        this.labelPoints = [];\n        for (let iSegment = 0; iSegment < segments.length; ++iSegment) {\n            let segment = segments[iSegment];\n            let nKpoints = segment.length;\n            let kPointIndices = [0, nKpoints - 1];\n            for (let iKpoint of kPointIndices) {\n                let kpoint = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().fromArray(segment[iKpoint]).multiplyScalar(1E-10);\n                kpoint.applyMatrix3(basisMatrix);\n                kpathGeometry.vertices.push(kpoint);\n                // Create the label for the first point in the segment\n                if (labels) {\n                    if (iKpoint === 0 || iKpoint === nKpoints - 1) {\n                        let label = \"\";\n                        if (iKpoint === 0) {\n                            label = labels[iSegment][0];\n                        }\n                        else if (iKpoint === nKpoints - 1) {\n                            label = labels[iSegment][1];\n                        }\n                        // Check if this position has alread been marked\n                        let labelExists = false;\n                        for (let iLabel = 0; iLabel < this.labelPoints.length; ++iLabel) {\n                            let testPos = this.labelPoints[iLabel].position;\n                            let delta = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]()\n                                .copy(kpoint)\n                                .addScaledVector(testPos, -1.0)\n                                .length();\n                            if (delta < 1E-5) {\n                                labelExists = true;\n                            }\n                        }\n                        // Add a label position if it wasn't marked already\n                        if (!labelExists) {\n                            labelMap[label] = true;\n                            let symmPoint = generateSymmPoint(kpoint, label);\n                            this.info.add(symmPoint);\n                            this.labelPoints.push(symmPoint);\n                        }\n                    }\n                }\n            }\n        }\n        let kpath = new three__WEBPACK_IMPORTED_MODULE_1__[\"Line\"](kpathGeometry, kpathMaterial);\n        this.info.add(kpath);\n        let mesh = new three__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"](bzGeometry, bzMaterial);\n        this.zone.add(mesh);\n        this.cornerPoints = new three__WEBPACK_IMPORTED_MODULE_1__[\"Points\"](bzGeometry);\n        this.cornerPoints.visible = true;\n    }\n}\n\n\n//# sourceURL=webpack://materia/./src/js/brillouinzoneviewer.js?");

/***/ }),

/***/ "./src/js/materia.js":
/*!***************************!*\
  !*** ./src/js/materia.js ***!
  \***************************/
/*! exports provided: StructureViewer, BrillouinZoneViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _structureviewer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./structureviewer */ \"./src/js/structureviewer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StructureViewer\", function() { return _structureviewer__WEBPACK_IMPORTED_MODULE_0__[\"StructureViewer\"]; });\n\n/* harmony import */ var _brillouinzoneviewer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./brillouinzoneviewer */ \"./src/js/brillouinzoneviewer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BrillouinZoneViewer\", function() { return _brillouinzoneviewer__WEBPACK_IMPORTED_MODULE_1__[\"BrillouinZoneViewer\"]; });\n\n\n\n\n\n\n//# sourceURL=webpack://materia/./src/js/materia.js?");

/***/ }),

/***/ "./src/js/orthographiccontrols.js":
/*!****************************************!*\
  !*** ./src/js/orthographiccontrols.js ***!
  \****************************************/
/*! exports provided: OrthographicControls */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OrthographicControls\", function() { return OrthographicControls; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * @author Eberhard Graether / http://egraether.com/\n * @author Mark Lundin \t/ http://mark-lundin.com\n * @author Simone Manini / http://daron1337.github.io\n * @author Luca Antiga \t/ http://lantiga.github.io\n * @author Lauri Himanen\n */\nvar changeEvent = new CustomEvent('change');\nvar startEvent = new CustomEvent('start');\nvar endEvent = new CustomEvent('end');\nvar STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };\nvar EPS = 0.0001;\nclass OrthographicControls {\n    constructor(object, domElement) {\n        this._state = STATE.NONE;\n        this.object = object;\n        this.domElement = (domElement !== undefined) ? domElement : document;\n        // Public\n        this.enabled = true;\n        this.screen = { left: 0, top: 0, width: 0, height: 0 };\n        this.rotateSpeed = 1.0;\n        this.zoomSpeed = 0.2;\n        this.panSpeed = 0.3;\n        this.enableRotate = true;\n        this.enableZoom = true;\n        this.enablePan = true;\n        this.staticMoving = false;\n        this.dynamicDampingFactor = 0.2;\n        this.minDistance = 0;\n        this.maxDistance = Infinity;\n        this.keys = [65 /*A*/, 83 /*S*/, 68 /*D*/];\n        // Private\n        this.rotationCenter = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\n        this.target = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\n        this._prevState = STATE.NONE,\n            this._eye = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](),\n            this._movePrev = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](),\n            this._moveCurr = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](),\n            this._lastAxis = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](),\n            this._lastAngle = 0,\n            this._lastPosition = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\n        this._zoomStart = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](),\n            this._zoomEnd = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](),\n            this._touchZoomDistanceStart = 0,\n            this._touchZoomDistanceEnd = 0,\n            this._panStart = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](),\n            this._panEnd = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\n        this._zoomed = false;\n        // For reset\n        this.rotationCenter0 = this.rotationCenter.clone();\n        this.target0 = this.target.clone();\n        this.position0 = this.object.position.clone();\n        this.up0 = this.object.up.clone();\n        this.zoom0 = this.object.zoom;\n        this.domElement.addEventListener('contextmenu', this.contextmenu.bind(this), false);\n        this.domElement.addEventListener('mousedown', this.mousedown.bind(this), false);\n        this.domElement.addEventListener('mousewheel', this.mousewheel.bind(this), false);\n        this.domElement.addEventListener('MozMousePixelScroll', this.mousewheel.bind(this), false); // firefox\n        this.domElement.addEventListener('touchstart', this.touchstart.bind(this), false);\n        this.domElement.addEventListener('touchend', this.touchend.bind(this), false);\n        this.domElement.addEventListener('touchmove', this.touchmove.bind(this), false);\n        window.addEventListener('keydown', this.keydown.bind(this), false);\n        window.addEventListener('keyup', this.keyup.bind(this), false);\n        window.addEventListener('keydown', this.keydown.bind(this), false);\n        document.addEventListener('mousemove', this.mousemove.bind(this), false);\n        document.addEventListener('mouseup', this.mouseup.bind(this), false);\n        this.handleResize();\n        // force an update at start\n        this.update();\n    }\n    handleResize() {\n        if (this.domElement === document) {\n            this.screen.left = 0;\n            this.screen.top = 0;\n            this.screen.width = window.innerWidth;\n            this.screen.height = window.innerHeight;\n        }\n        else {\n            var box = this.domElement.getBoundingClientRect();\n            // adjustments come from similar code in the jquery offset() function\n            var d = this.domElement.ownerDocument.documentElement;\n            this.screen.left = box.left + window.pageXOffset - d.clientLeft;\n            this.screen.top = box.top + window.pageYOffset - d.clientTop;\n            this.screen.width = box.width;\n            this.screen.height = box.height;\n        }\n    }\n    ;\n    handleEvent(event) {\n        if (typeof this[event.type] == 'function') {\n            this[event.type](event);\n        }\n    }\n    ;\n    getMouseOnScreen(pageX, pageY) {\n        var vector = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\n        vector.set((pageX - this.screen.left) / this.screen.width, (pageY - this.screen.top) / this.screen.width);\n        return vector;\n    }\n    ;\n    getMouseOnCircle(pageX, pageY) {\n        var vector = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\n        vector.set(((pageX - this.screen.width * 0.5 - this.screen.left) / (this.screen.width * 0.5)), ((this.screen.height + 2 * (this.screen.top - pageY)) / this.screen.width) // screen.width intentional\n        );\n        return vector;\n    }\n    ;\n    /**\n      * Used to trigger rotation after a move has been detected and stored in\n      * this.movePrev and this.moveCurr.\n      */\n    rotateCamera() {\n        var axis = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](), quaternion = new three__WEBPACK_IMPORTED_MODULE_0__[\"Quaternion\"](), eyeDirection = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](), objectUpDirection = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](), objectSidewaysDirection = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](), moveDirection = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](), angle;\n        moveDirection.set(this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0);\n        angle = moveDirection.length();\n        if (angle) {\n            this._eye.copy(this.object.position).sub(this.rotationCenter);\n            eyeDirection.copy(this._eye).normalize();\n            objectUpDirection.copy(this.object.up).normalize();\n            objectSidewaysDirection.crossVectors(objectUpDirection, eyeDirection).normalize();\n            objectUpDirection.setLength(this._moveCurr.y - this._movePrev.y);\n            objectSidewaysDirection.setLength(this._moveCurr.x - this._movePrev.x);\n            moveDirection.copy(objectUpDirection.add(objectSidewaysDirection));\n            axis.crossVectors(moveDirection, this._eye).normalize();\n            var zoomFactor = this.object.zoom;\n            angle *= this.rotateSpeed;\n            angle /= zoomFactor;\n            quaternion.setFromAxisAngle(axis, angle);\n            this._eye.applyQuaternion(quaternion);\n            this.object.up.applyQuaternion(quaternion);\n            this._lastAxis.copy(axis);\n            this._lastAngle = angle;\n        }\n        else if (!this.staticMoving && this._lastAngle) {\n            this._lastAngle *= Math.sqrt(1.0 - this.dynamicDampingFactor);\n            this._eye.copy(this.object.position).sub(this.rotationCenter);\n            quaternion.setFromAxisAngle(this._lastAxis, this._lastAngle);\n            this._eye.applyQuaternion(quaternion);\n            this.object.up.applyQuaternion(quaternion);\n        }\n        this._movePrev.copy(this._moveCurr);\n    }\n    ;\n    zoomCamera() {\n        var factor;\n        if (this._state === STATE.TOUCH_ZOOM_PAN) {\n            factor = this._touchZoomDistanceStart / this._touchZoomDistanceEnd;\n            this._touchZoomDistanceStart = this._touchZoomDistanceEnd;\n            this.object.zoom /= factor;\n            this.object.updateProjectionMatrix();\n            this._zoomed = true;\n        }\n        else {\n            factor = 1.0 + (this._zoomEnd.y - this._zoomStart.y);\n            if (factor !== 1.0 && factor > 0.0) {\n                this.object.zoom /= factor;\n                this.object.updateProjectionMatrix();\n                this._zoomed = true;\n                if (this.staticMoving) {\n                    this._zoomStart.copy(this._zoomEnd);\n                }\n                else {\n                    this._zoomStart.y += (this._zoomEnd.y - this._zoomStart.y) * this.dynamicDampingFactor;\n                }\n            }\n        }\n    }\n    ;\n    panCamera() {\n        var mouseChange = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](), objectUp = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](), pan = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\n        mouseChange.copy(this._panEnd).sub(this._panStart);\n        if (mouseChange.lengthSq()) {\n            var zoomFactor = this.object.zoom;\n            mouseChange.multiplyScalar(this.panSpeed / zoomFactor);\n            pan.copy(this._eye).cross(this.object.up).setLength(mouseChange.x);\n            pan.add(objectUp.copy(this.object.up).setLength(mouseChange.y));\n            this.object.position.add(pan);\n            this.rotationCenter.add(pan);\n            if (this.staticMoving) {\n                this._panStart.copy(this._panEnd);\n            }\n            else {\n                this._panStart.add(mouseChange.subVectors(this._panEnd, this._panStart).multiplyScalar(this.dynamicDampingFactor));\n            }\n        }\n        ;\n    }\n    ;\n    checkDistances() {\n        if (this.enableZoom || this.enablePan) {\n            if (this._eye.lengthSq() > this.maxDistance * this.maxDistance) {\n                this.object.position.addVectors(this.rotationCenter, this._eye.setLength(this.maxDistance));\n                this._zoomStart.copy(this._zoomEnd);\n            }\n            if (this._eye.lengthSq() < this.minDistance * this.minDistance) {\n                this.object.position.addVectors(this.rotationCenter, this._eye.setLength(this.minDistance));\n                this._zoomStart.copy(this._zoomEnd);\n            }\n        }\n    }\n    ;\n    /**\n      * Used to update the controlled object after the user has manipulated the\n      * scene. Will also request a new render if the manipulation has changed\n      * the scene.\n      */\n    update() {\n        this._eye.subVectors(this.object.position, this.rotationCenter);\n        if (this.enableRotate) {\n            this.rotateCamera();\n        }\n        if (this.enableZoom) {\n            this.zoomCamera();\n        }\n        if (this.enablePan) {\n            this.panCamera();\n        }\n        this.object.position.addVectors(this.rotationCenter, this._eye);\n        this.checkDistances();\n        this.object.lookAt(this.rotationCenter);\n        let delta = this._lastPosition.distanceToSquared(this.object.position);\n        if (delta > EPS || this._zoomed) {\n            this.dispatchEvent(changeEvent);\n            this._lastPosition.copy(this.object.position);\n            this._zoomed = false;\n        }\n    }\n    ;\n    /**\n     * Saves the current configuration as the reset configuration.\n     */\n    saveReset() {\n        this.rotationCenter0.copy(this.rotationCenter);\n        this.position0.copy(this.object.position);\n        this.up0.copy(this.object.up);\n        this.zoom0 = this.object.zoom;\n    }\n    ;\n    reset() {\n        this._state = STATE.NONE;\n        this._prevState = STATE.NONE;\n        this.rotationCenter.copy(this.rotationCenter0);\n        this.object.position.copy(this.position0);\n        this.object.up.copy(this.up0);\n        this._eye.subVectors(this.object.position, this.rotationCenter);\n        this.object.lookAt(this.rotationCenter);\n        this.object.zoom = this.zoom0;\n        this.object.updateProjectionMatrix();\n        this.dispatchEvent(changeEvent);\n        this._lastPosition.copy(this.object.position);\n    }\n    ;\n    dispose() {\n        this.domElement.removeEventListener('contextmenu', this.contextmenu.bind(this), false);\n        this.domElement.removeEventListener('mousedown', this.mousedown.bind(this), false);\n        this.domElement.removeEventListener('mousewheel', this.mousewheel.bind(this), false);\n        this.domElement.removeEventListener('MozMousePixelScroll', this.mousewheel.bind(this), false); // firefox\n        this.domElement.removeEventListener('touchstart', this.touchstart.bind(this), false);\n        this.domElement.removeEventListener('touchend', this.touchend.bind(this), false);\n        this.domElement.removeEventListener('touchmove', this.touchmove.bind(this), false);\n        document.removeEventListener('mousemove', this.mousemove.bind(this), false);\n        document.removeEventListener('mouseup', this.mouseup.bind(this), false);\n        window.removeEventListener('keydown', this.keydown.bind(this), false);\n        window.removeEventListener('keyup', this.keyup.bind(this), false);\n    }\n    ;\n    keydown(event) {\n        if (this.enabled === false)\n            return;\n        window.removeEventListener('keydown', this.keydown.bind(this));\n        this._prevState = this._state;\n        if (this._state !== STATE.NONE) {\n            return;\n        }\n        else if (event.keyCode === this.keys[STATE.ROTATE] && this.enableRotate) {\n            this._state = STATE.ROTATE;\n        }\n        else if (event.keyCode === this.keys[STATE.ZOOM] && this.enableZoom) {\n            this._state = STATE.ZOOM;\n        }\n        else if (event.keyCode === this.keys[STATE.PAN] && this.enablePan) {\n            this._state = STATE.PAN;\n        }\n    }\n    keyup(event) {\n        if (this.enabled === false)\n            return;\n        this._state = this._prevState;\n    }\n    mousedown(event) {\n        if (this.enabled === false)\n            return;\n        event.preventDefault();\n        event.stopPropagation();\n        if (this._state === STATE.NONE) {\n            this._state = event.button;\n        }\n        if (this._state === STATE.ROTATE && this.enableRotate) {\n            this._moveCurr.copy(this.getMouseOnCircle(event.pageX, event.pageY));\n            this._movePrev.copy(this._moveCurr);\n        }\n        else if (this._state === STATE.ZOOM && this.enableZoom) {\n            this._zoomStart.copy(this.getMouseOnScreen(event.pageX, event.pageY));\n            this._zoomEnd.copy(this._zoomStart);\n        }\n        else if (this._state === STATE.PAN && this.enablePan) {\n            this._panStart.copy(this.getMouseOnScreen(event.pageX, event.pageY));\n            this._panEnd.copy(this._panStart);\n        }\n        this.dispatchEvent(startEvent);\n    }\n    mousemove(event) {\n        if (this.enabled === false)\n            return;\n        event.preventDefault();\n        event.stopPropagation();\n        if (this._state === STATE.ROTATE && this.enableRotate) {\n            this._movePrev.copy(this._moveCurr);\n            this._moveCurr.copy(this.getMouseOnCircle(event.pageX, event.pageY));\n        }\n        else if (this._state === STATE.ZOOM && this.enableZoom) {\n            this._zoomEnd.copy(this.getMouseOnScreen(event.pageX, event.pageY));\n        }\n        else if (this._state === STATE.PAN && this.enablePan) {\n            this._panEnd.copy(this.getMouseOnScreen(event.pageX, event.pageY));\n        }\n        // Trigger update after moving mouse\n        this.update();\n    }\n    mouseup(event) {\n        if (this.enabled === false)\n            return;\n        event.preventDefault();\n        event.stopPropagation();\n        this._state = STATE.NONE;\n        document.removeEventListener('mousemove', this.mousemove.bind(this));\n        document.removeEventListener('mouseup', this.mouseup.bind(this));\n        this.dispatchEvent(endEvent);\n    }\n    mousewheel(event) {\n        if (this.enabled === false)\n            return;\n        event.preventDefault();\n        event.stopPropagation();\n        let delta = 0;\n        // WebKit / Opera / Explorer 9\n        if (event.wheelDelta) {\n            delta = event.wheelDelta;\n            // Firefox\n        }\n        else if (event.detail) {\n            delta = -event.detail;\n        }\n        // Normalization due to inconsistent scroll speeds across browsers.\n        delta /= Math.abs(delta);\n        this._zoomStart.y += delta * this.zoomSpeed;\n        this.dispatchEvent(startEvent);\n        this.dispatchEvent(endEvent);\n        // Trigger update after wheel scroll\n        this.update();\n    }\n    touchstart(event) {\n        if (this.enabled === false)\n            return;\n        switch (event.touches.length) {\n            case 1:\n                this._state = STATE.TOUCH_ROTATE;\n                this._moveCurr.copy(this.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n                this._movePrev.copy(this._moveCurr);\n                break;\n            default: // 2 or more\n                this._state = STATE.TOUCH_ZOOM_PAN;\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);\n                var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n                var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n                this._panStart.copy(this.getMouseOnScreen(x, y));\n                this._panEnd.copy(this._panStart);\n                break;\n        }\n        this.dispatchEvent(startEvent);\n    }\n    touchmove(event) {\n        if (this.enabled === false)\n            return;\n        event.preventDefault();\n        event.stopPropagation();\n        switch (event.touches.length) {\n            case 1:\n                this._movePrev.copy(this._moveCurr);\n                this._moveCurr.copy(this.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n                break;\n            default: // 2 or more\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                this._touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);\n                var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n                var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n                this._panEnd.copy(this.getMouseOnScreen(x, y));\n                break;\n        }\n        // Trigger update after touch move\n        this.update();\n    }\n    touchend(event) {\n        if (this.enabled === false)\n            return;\n        switch (event.touches.length) {\n            case 0:\n                this._state = STATE.NONE;\n                break;\n            case 1:\n                this._state = STATE.TOUCH_ROTATE;\n                this._moveCurr.copy(this.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n                this._movePrev.copy(this._moveCurr);\n                break;\n        }\n        this.dispatchEvent(endEvent);\n    }\n    contextmenu(event) {\n        event.preventDefault();\n    }\n    addEventListener(type, listener) {\n        if (this._listeners === undefined)\n            this._listeners = {};\n        var listeners = this._listeners;\n        if (listeners[type] === undefined) {\n            listeners[type] = [];\n        }\n        if (listeners[type].indexOf(listener) === -1) {\n            listeners[type].push(listener);\n        }\n    }\n    hasEventListener(type, listener) {\n        if (this._listeners === undefined)\n            return false;\n        var listeners = this._listeners;\n        return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;\n    }\n    removeEventListener(type, listener) {\n        if (this._listeners === undefined)\n            return;\n        var listeners = this._listeners;\n        var listenerArray = listeners[type];\n        if (listenerArray !== undefined) {\n            var index = listenerArray.indexOf(listener);\n            if (index !== -1) {\n                listenerArray.splice(index, 1);\n            }\n        }\n    }\n    dispatchEvent(event) {\n        if (this._listeners === undefined)\n            return;\n        var listeners = this._listeners;\n        var listenerArray = listeners[event.type];\n        if (listenerArray !== undefined) {\n            var array = listenerArray.slice(0);\n            for (var i = 0, l = array.length; i < l; i++) {\n                array[i].call(this, event);\n            }\n        }\n    }\n}\n;\n\n\n//# sourceURL=webpack://materia/./src/js/orthographiccontrols.js?");

/***/ }),

/***/ "./src/js/structureviewer.js":
/*!***********************************!*\
  !*** ./src/js/structureviewer.js ***!
  \***********************************/
/*! exports provided: StructureViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StructureViewer\", function() { return StructureViewer; });\n/* harmony import */ var _viewer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./viewer */ \"./src/js/viewer.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);\n\n\n/**\n * Class for visualizing an atomic structure.\n */\nclass StructureViewer extends _viewer__WEBPACK_IMPORTED_MODULE_0__[\"Viewer\"] {\n    constructor() {\n        super(...arguments);\n        this.updateBonds = false;\n        this.atomicRadii = []; // Contains the atomic radii\n        this.elementColors = []; // Contains the element colors\n        this.lights = []; // Contains the lights in the scene\n        this.bondFills = []; // Contains the bulk of the bonds\n        this.atomFills = []; // Contains the bulk of the atoms\n        this.atomOutlines = []; // Contains the outlines of the atoms\n        this.axisLabels = []; // List of all labels in the view.\n        this.elementNames = [\n            'H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si',\n            'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni',\n            'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb',\n            'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe',\n            'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho',\n            'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg',\n            'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U', 'Np',\n            'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr', 'Rf', 'Ha', 'Sg',\n            'Ns', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og' // Mt = 109\n        ];\n        this.elementNumbers = {\n            'H': 1, 'He': 2, 'Li': 3, 'Be': 4,\n            'B': 5, 'C': 6, 'N': 7, 'O': 8, 'F': 9,\n            'Ne': 10, 'Na': 11, 'Mg': 12, 'Al': 13, 'Si': 14,\n            'P': 15, 'S': 16, 'Cl': 17, 'Ar': 18, 'K': 19,\n            'Ca': 20, 'Sc': 21, 'Ti': 22, 'V': 23, 'Cr': 24,\n            'Mn': 25, 'Fe': 26, 'Co': 27, 'Ni': 28, 'Cu': 29,\n            'Zn': 30, 'Ga': 31, 'Ge': 32, 'As': 33, 'Se': 34,\n            'Br': 35, 'Kr': 36, 'Rb': 37, 'Sr': 38, 'Y': 39,\n            'Zr': 40, 'Nb': 41, 'Mo': 42, 'Tc': 43, 'Ru': 44,\n            'Rh': 45, 'Pd': 46, 'Ag': 47, 'Cd': 48, 'In': 49,\n            'Sn': 50, 'Sb': 51, 'Te': 52, 'I': 53, 'Xe': 54,\n            'Cs': 55, 'Ba': 56, 'La': 57, 'Ce': 58, 'Pr': 59,\n            'Nd': 60, 'Pm': 61, 'Sm': 62, 'Eu': 63, 'Gd': 64,\n            'Tb': 65, 'Dy': 66, 'Ho': 67, 'Er': 68, 'Tm': 69,\n            'Yb': 70, 'Lu': 71, 'Hf': 72, 'Ta': 73, 'W': 74,\n            'Re': 75, 'Os': 76, 'Ir': 77, 'Pt': 78, 'Au': 79,\n            'Hg': 80, 'Tl': 81, 'Pb': 82, 'Bi': 83, 'Po': 84,\n            'At': 85, 'Rn': 86, 'Fr': 87, 'Ra': 88, 'Ac': 89,\n            'Th': 90, 'Pa': 91, 'U': 92, 'Np': 93, 'Pu': 94,\n            'Am': 95, 'Cm': 96, 'Bk': 97, 'Cf': 98, 'Es': 99,\n            'Fm': 100, 'Md': 101, 'No': 102, 'Lr': 103,\n        };\n        //  Covalent radii revisited,\n        //  Beatriz Cordero, Verónica Gómez, Ana E. Platero-Prats, Marc Revés,\n        //  Jorge Echeverría, Eduard Cremades, Flavia Barragán and Santiago Alvarez,\n        //  Dalton Trans., 2008, 2832-2838 DOI:10.1039/B801115J\n        this.missing = 0.2;\n        this.covalentRadii = [\n            this.missing,\n            0.31,\n            0.28,\n            1.28,\n            0.96,\n            0.84,\n            0.76,\n            0.71,\n            0.66,\n            0.57,\n            0.58,\n            1.66,\n            1.41,\n            1.21,\n            1.11,\n            1.07,\n            1.05,\n            1.02,\n            1.06,\n            2.03,\n            1.76,\n            1.7,\n            1.6,\n            1.53,\n            1.39,\n            1.39,\n            1.32,\n            1.26,\n            1.24,\n            1.32,\n            1.22,\n            1.22,\n            1.2,\n            1.19,\n            1.2,\n            1.2,\n            1.16,\n            2.2,\n            1.95,\n            1.9,\n            1.75,\n            1.64,\n            1.54,\n            1.47,\n            1.46,\n            1.42,\n            1.39,\n            1.45,\n            1.44,\n            1.42,\n            1.39,\n            1.39,\n            1.38,\n            1.39,\n            1.4,\n            2.44,\n            2.15,\n            2.07,\n            2.04,\n            2.03,\n            2.01,\n            1.99,\n            1.98,\n            1.98,\n            1.96,\n            1.94,\n            1.92,\n            1.92,\n            1.89,\n            1.9,\n            1.87,\n            1.87,\n            1.75,\n            1.7,\n            1.62,\n            1.51,\n            1.44,\n            1.41,\n            1.36,\n            1.36,\n            1.32,\n            1.45,\n            1.46,\n            1.48,\n            1.4,\n            1.5,\n            1.5,\n            2.6,\n            2.21,\n            2.15,\n            2.06,\n            2.0,\n            1.96,\n            1.9,\n            1.87,\n            1.8,\n            1.69,\n            this.missing,\n            this.missing,\n            this.missing,\n            this.missing,\n            this.missing,\n            this.missing,\n            this.missing,\n        ];\n        // Jmol colors. See: http://jmol.sourceforge.net/jscolors/#color_U\n        this.jmolColors = [\n            \"#ff0000\",\n            \"#ffffff\",\n            \"#d9ffff\",\n            \"#cc80ff\",\n            \"#c2ff00\",\n            \"#ffb5b5\",\n            \"#909090\",\n            \"#3050f8\",\n            \"#ff0d0d\",\n            \"#90e050\",\n            \"#b3e3f5\",\n            \"#ab5cf2\",\n            \"#8aff00\",\n            \"#bfa6a6\",\n            \"#f0c8a0\",\n            \"#ff8000\",\n            \"#ffff30\",\n            \"#1ff01f\",\n            \"#80d1e3\",\n            \"#8f40d4\",\n            \"#3dff00\",\n            \"#e6e6e6\",\n            \"#bfc2c7\",\n            \"#a6a6ab\",\n            \"#8a99c7\",\n            \"#9c7ac7\",\n            \"#e06633\",\n            \"#f090a0\",\n            \"#50d050\",\n            \"#c88033\",\n            \"#7d80b0\",\n            \"#c28f8f\",\n            \"#668f8f\",\n            \"#bd80e3\",\n            \"#ffa100\",\n            \"#a62929\",\n            \"#5cb8d1\",\n            \"#702eb0\",\n            \"#00ff00\",\n            \"#94ffff\",\n            \"#94e0e0\",\n            \"#73c2c9\",\n            \"#54b5b5\",\n            \"#3b9e9e\",\n            \"#248f8f\",\n            \"#0a7d8c\",\n            \"#006985\",\n            \"#c0c0c0\",\n            \"#ffd98f\",\n            \"#a67573\",\n            \"#668080\",\n            \"#9e63b5\",\n            \"#d47a00\",\n            \"#940094\",\n            \"#429eb0\",\n            \"#57178f\",\n            \"#00c900\",\n            \"#70d4ff\",\n            \"#ffffc7\",\n            \"#d9ffc7\",\n            \"#c7ffc7\",\n            \"#a3ffc7\",\n            \"#8fffc7\",\n            \"#61ffc7\",\n            \"#45ffc7\",\n            \"#30ffc7\",\n            \"#1fffc7\",\n            \"#00ff9c\",\n            \"#00e675\",\n            \"#00d452\",\n            \"#00bf38\",\n            \"#00ab24\",\n            \"#4dc2ff\",\n            \"#4da6ff\",\n            \"#2194d6\",\n            \"#267dab\",\n            \"#266696\",\n            \"#175487\",\n            \"#d0d0e0\",\n            \"#ffd123\",\n            \"#b8b8d0\",\n            \"#a6544d\",\n            \"#575961\",\n            \"#9e4fb5\",\n            \"#ab5c00\",\n            \"#754f45\",\n            \"#428296\",\n            \"#420066\",\n            \"#007d00\",\n            \"#70abfa\",\n            \"#00baff\",\n            \"#00a1ff\",\n            \"#008fff\",\n            \"#0080ff\",\n            \"#006bff\",\n            \"#545cf2\",\n            \"#785ce3\",\n            \"#8a4fe3\",\n            \"#a136d4\",\n            \"#b31fd4\",\n            \"#b31fba\",\n            \"#b30da6\",\n            \"#bd0d87\",\n            \"#c70066\",\n            \"#cc0059\",\n            \"#d1004f\",\n            \"#d90045\",\n            \"#e00038\",\n            \"#e6002e\",\n            \"#eb0026\",\n        ];\n    }\n    /*\n     * Overrides the implementation from the base class, as we need two scenes:\n     * one for the structure and another for the information that is laid on top.\n     */\n    setupScenes() {\n        this.scenes = [];\n        this.sceneStructure = new three__WEBPACK_IMPORTED_MODULE_1__[\"Scene\"]();\n        this.scenes.push(this.sceneStructure);\n        this.sceneInfo = new three__WEBPACK_IMPORTED_MODULE_1__[\"Scene\"]();\n        this.scenes.push(this.sceneInfo);\n    }\n    /**\n     * Used to setup the visualization options.\n     *\n     * @param {boolean} options A Javascript object containing the options. See\n     *   below for the subparameters.\n     *\n     * @param {(string|number[])} options.layout.periodicity How periodicity\n     *   is handled in the visualization. Available options are:\n     *    - \"none\": Visualized as is.\n     *    - \"wrap\": Positions wrapped within unit cell.\n     *    - \"boundary\": Positions that are on the cell boundaries are repeated.\n     *    - [a, b, c]: Positions are repeated along each lattice vector the\n     *      given amount of times.\n     * @param {number[]} options.layout.translation A fixed cartesian\n     *   translation to be applied to the atoms.\n     * @param {string} options.layout.viewCenter Determines how the view is\n     *   initially centered. Available options are:\n     *    - \"COC\": Center of cell.\n     *    - \"COP\": Center of atom positions.\n     * @param {string} options.layout.viewRotation.align.top Optional alignment\n     * indicating which lattice basis vector should point upwards. Possible\n     * values are: \"a\", \"b\", \"c\", \"-a\", \"-b\", \"-c\".\n     * @param {string} options.layout.viewRotation.align.right Optional alignment\n     * indicating which lattice basis vector should point to the right (more\n     * precisely: the cross-product of options.layout.viewRotation.align.top\n     * and options.layout.viewRotation.align.right will point away from the\n     * screen.). Possible values are: \"a\", \"b\", \"c\", \"-a\", \"-b\", \"-c\".\n     * @param {number[][]} options.layout.viewRotation.align.rotations Optional\n     * rotations that are applied after the alignment has been done (see\n     * options.layout.viewRotation.align). The rotations are given as a list of\n     * 4-element arrays containing the rotations axis and rotation angle in\n     * degrees. E.g. [[1, 0, 0, 90]] would apply a 90 degree rotation with\n     * respect to the x-coordinate. If multiple rotations are specified, they\n     * will be applied in the given order. Notice that these rotations are\n     * applied with respect to a global coordinate system, not the coordinate\n     * system of the structure. In this global coordinate system [1, 0, 0]\n     * points to the right, [0, 1, 0] points upwards and [0, 0, 1] points away\n     * from the screen.\n     *\n     * @param {boolean} options.latticeConstants.enabled Show lattice parameters\n     * @param {string} options.latticeConstants.font Font size for lattice\n     *   constants. Applied as default to all labels, can be overridden\n     *   individually for each lattice constant.\n     * @param {string} options.latticeConstants.a.color Color applied to the\n     *   lattice constant of the first lattice vector.\n     * @param {string} options.latticeConstants.a.font Font family applied to the\n     *   lattice constant of the first lattice vector.\n     * @param {number} options.latticeConstants.a.size Font size applied to the\n     *   lattice constant of the first lattice vector.\n     * @param {string} options.latticeConstants.b.color Color applied to the\n     *   lattice constant of the second lattice vector.\n     * @param {string} options.latticeConstants.b.font Font family applied to the\n     *   lattice constant of the second lattice vector.\n     * @param {number} options.latticeConstants.b.size Font size applied to the\n     *   lattice constant of the second lattice vector.\n     * @param {string} options.latticeConstants.c.color Color applied to the\n     *   lattice constant of the second lattice vector.\n     * @param {string} options.latticeConstants.c.font Font family applied to the\n     *   lattice constant of the third lattice vector.\n     * @param {number} options.latticeConstants.c.size Font size applied to the\n     *   lattice constant of the third lattice vector.\n     * @param {string} options.latticeConstants.alpha.color Color applied to the\n     *   angle between the second and third lattice vector.\n     * @param {string} options.latticeConstants.alpha.font Font family applied to the\n     *   angle between the second and third lattice vector.\n     * @param {number} options.latticeConstants.alpha.size Font size applied to the\n     *   lattice constant of the third lattice vector.\n     * @param {string} options.latticeConstants.beta.color Color applied to the\n     *   angle between the first and third lattice vector.\n     * @param {string} options.latticeConstants.beta.font Font family applied to the\n     *   angle between the first and third lattice vector.\n     * @param {number} options.latticeConstants.beta.size Font size applied to the\n     *   angle between the first and third lattice vector.\n     * @param {string} options.latticeConstants.gamma.color Color applied to the\n     *   angle between the first and second lattice vector.\n     * @param {string} options.latticeConstants.gamma.font Font family applied to the\n     *   angle between the first and second lattice vector.\n     * @param {number} options.latticeConstants.gamma.size Font size applied to the\n     *   angle between the first and second lattice vector.\n     *\n     * @param {boolean} options.outline.enabled Used to enable or disable a\n     *   fixed color outline around atoms and bonds. Notice that enabling the\n     *   outline incurs a performance penalty.\n     * @param {string} options.outline.color Outline color.\n     * @param {number} options.outline.size Outline size.\n     *\n     * @param {boolean} options.cell.enabled Show unit cell wireframe.\n     * @param {boolean} options.cell.color Unit cell wireframe color.\n     * @param {boolean} options.cell.linewidth Unit cell wireframe line width.\n     * @param {boolean} options.cell.dashSize Unit cell wireframe dash size. Provide a value > 0 for a dashed line.\n     * @param {boolean} options.cell.gapSize Unit cell wireframe dash size. Provide a value > 0 for a dashed line.\n     *\n     * @param {boolean} options.bonds.enabled Show bonds.\n     * @param {number} options.bonds.radius Bond radius.\n     * @param {number} options.bonds.smoothness A value between 0-180 that\n     *   controls the number of polygons. Used as the angle between adjacent\n     *   cylinder/sphere sectors that indirectly controls the number of\n     *   polygons.\n     * @param {number} options.bonds.material.shininess Shininess of the bond material.\n     * @param {number} options.bonds.threshold Controls the automatic\n     *   detection of bonds between atoms. If custom bonds have not been\n     *   specified for the structure, bonds will be detected automatically with\n     *   the following criteria: distance <=\n     *   this.options.bonds.threshold * 1.1 * (radius1 + radius2)\n     *\n     * @param {number} options.atoms.smoothness A value between 0-180 that\n     *   controls the number of polygons. Used as the angle between adjacent\n     *   cylinder/sphere sectors that indirectly controls the number of\n     *   polygons.\n     * @param {number} options.atoms.material.shininess Shininess of the atom material.\n     * @param {string|number[]} options.atoms.radii The radii to use for atoms.\n     * Defaults to covalent radii. Available options are:\n     *\n     *   - \"covalent\": Covalent radii from DOI:10.1039/B801115J.\n     *   - Custom list of atomic radii. Provide an array of floating point\n     *     numbers where the index corresponds to an atomic number.\n     *\n     * @param {string|string[]} options.atoms.colors The colors to use\n     * for atoms. Available options are:\n     *\n     *   - \"Jmol\" (default): Jmol colors.\n     *   - Custom list of colors. Provide an array of hexadecimal colors where\n     *     the index corresponds to an atomic number.\n     *\n     * @param {number} options.atoms.scale Scaling factor for the atomic radii.\n     *\n     * @param {*} options.renderer.backgroundColor Color of the background.\n     * Provide an array with two values, the first being the hexadecimal color\n     * value and the second the opacity. E.g. [\"#ffffff\", 0] would produce a\n     * fully opaque background.\n     * @param {boolean} options.renderer.shadows.enabled Whether shows are cast\n     * by atoms onto others. Note that enabling this increases the\n     * computational cost for doing the visualization.\n     * @param {boolean} render Whether to perform a render after setting the\n     * options. Defaults to true. You should only disable this setting if you\n     * plan to do a render manually afterwards.\n     */\n    setOptions(options, render = true, reload = true) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        let defaultOptions = {\n            view: {\n                fitMargin: 0.5,\n            },\n            layout: {\n                periodicity: \"none\",\n                translation: [0, 0, 0],\n                viewCenter: \"COP\",\n                wrapTolerance: 0.05,\n            },\n            outline: {\n                enabled: true,\n                color: \"#000000\",\n                size: 0.025,\n            },\n            cell: {\n                enabled: true,\n                color: \"#000000\",\n                linewidth: 1.5,\n                dashSize: 0,\n                gapSize: 0\n            },\n            latticeConstants: {\n                enabled: true,\n                font: \"Arial\",\n                size: 0.7,\n                a: {\n                    enabled: true,\n                    color: \"#C52929\",\n                    label: \"a\",\n                },\n                b: {\n                    enabled: true,\n                    color: \"#47A823\",\n                    label: \"b\",\n                },\n                c: {\n                    enabled: true,\n                    color: \"#3B5796\",\n                    label: \"c\",\n                },\n                alpha: {\n                    enabled: true,\n                    color: \"#ffffff\",\n                    label: \"α\",\n                },\n                beta: {\n                    enabled: true,\n                    color: \"#ffffff\",\n                    label: \"β\",\n                },\n                gamma: {\n                    enabled: true,\n                    color: \"#ffffff\",\n                    label: \"γ\",\n                },\n            },\n            bonds: {\n                enabled: true,\n                material: {\n                    shininess: 30,\n                },\n                radius: 0.08,\n                threshold: 1,\n                smoothness: 145,\n            },\n            atoms: {\n                material: {\n                    shininess: 30,\n                },\n                colors: \"Jmol\",\n                radii: \"covalent\",\n                scale: 1,\n                smoothness: 165,\n            }\n        };\n        // Upon first call, fill the missing values with default options\n        if (Object.keys(this.options).length === 0) {\n            this.fillOptions(options, defaultOptions);\n            super.setOptions(defaultOptions);\n            // On subsequent calls update only the given values and simply do a full\n            // reload for the structure. This is not efficient by any means for most\n            // settings but gets the job done for now.\n        }\n        else {\n            this.fillOptions(options, this.options);\n            super.setOptions(this.options);\n            // Check if a full structure reload is required\n            if (reload) {\n                if (this.needFullReload(options) && this.structure !== undefined) {\n                    this.load(this.structure);\n                }\n                else {\n                    if (((_a = options === null || options === void 0 ? void 0 : options.latticeConstants) === null || _a === void 0 ? void 0 : _a.enabled) !== undefined) {\n                        this.toggleLatticeConstants(options.latticeConstants.enabled);\n                    }\n                    ;\n                    if (((_b = options === null || options === void 0 ? void 0 : options.cell) === null || _b === void 0 ? void 0 : _b.enabled) !== undefined) {\n                        this.toggleCell(options.cell.enabled);\n                    }\n                    ;\n                    if (((_c = options === null || options === void 0 ? void 0 : options.bonds) === null || _c === void 0 ? void 0 : _c.enabled) !== undefined) {\n                        this.toggleBonds(options.bonds.enabled);\n                    }\n                    ;\n                    if (((_e = (_d = options === null || options === void 0 ? void 0 : options.renderer) === null || _d === void 0 ? void 0 : _d.shadows) === null || _e === void 0 ? void 0 : _e.enabled) !== undefined) {\n                        this.toggleShadows(options.renderer.shadows.enabled);\n                    }\n                    ;\n                }\n            }\n            if (((_f = options === null || options === void 0 ? void 0 : options.renderer) === null || _f === void 0 ? void 0 : _f.backgroundColor) !== undefined) {\n                this.setBackgroundColor((_g = options === null || options === void 0 ? void 0 : options.renderer) === null || _g === void 0 ? void 0 : _g.backgroundColor);\n            }\n            ;\n            if (render) {\n                this.render();\n            }\n        }\n    }\n    /**\n     * Used to determine if a full realod of the structure is needed given the\n     * updated options.\n     * @param {*} options The updated options.\n     */\n    needFullReload(options) {\n        // Options that do not require a full reload\n        let noReload = {\n            cell: {\n                enabled: true,\n            },\n            latticeConstants: {\n                enabled: true,\n            },\n            bonds: {\n                enabled: true,\n            },\n            shadows: {\n                enabled: true,\n            }\n        };\n        // Check it anything else is defined besides the options that do not need\n        // a full reload.\n        // Overrride with settings from user and child class\n        function eachRecursive(source, target) {\n            for (var k in source) {\n                // Find variable in default settings\n                if (source[k] !== null && Object.prototype.toString.call(source[k]) === \"[object Object]\") {\n                    // If the current level is not defined in the target, it is\n                    // initialized with empty object.\n                    if (target[k] === undefined) {\n                        return true;\n                    }\n                    let update = eachRecursive(source[k], target[k]);\n                    if (update) {\n                        return true;\n                    }\n                }\n                else {\n                    if (target[k] === undefined) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        return eachRecursive(options, noReload);\n    }\n    /**\n     * Returns the currently set options.\n     * @returns {Object} The current options.\n     */\n    getOptions() {\n        return this.options;\n    }\n    /**\n     * Returns information about the elements included in the structure.\n     * @returns {Object} The current options.\n     */\n    getElementInfo() {\n        return this.elements;\n    }\n    /**\n     * Hides or shows the lattice parameter labels.\n     */\n    toggleLatticeConstants(value) {\n        if (this.latticeConstants !== undefined) {\n            this.latticeConstants.visible = value;\n            this.angleArcs.visible = value;\n        }\n    }\n    /**\n     * Hides or shows the cell.\n     */\n    toggleCell(value) {\n        if (this.convCell !== undefined) {\n            this.convCell.visible = value;\n        }\n        if (this.primCell !== undefined) {\n            this.primCell.visible = value;\n        }\n    }\n    /**\n     * Hides or shows the bonds.\n     */\n    toggleBonds(value) {\n        if (value) {\n            this.createBonds();\n        }\n        if (this.bonds !== undefined) {\n            this.bonds.visible = value;\n        }\n    }\n    /**\n     * Hides or shows the shadows.\n     */\n    toggleShadows(value) {\n        this.renderer.shadowMap.enabled = value;\n        for (let i = 0; i < this.lights.length; ++i) {\n            let light = this.lights[i];\n            light.castShadow = value;\n        }\n        for (let i = 0; i < this.atomFills.length; ++i) {\n            let atom = this.atomFills[i];\n            atom.receiveShadow = value;\n            atom.castShadow = value;\n            atom.material.needsUpdate = true;\n        }\n        for (let i = 0; i < this.bondFills.length; ++i) {\n            let bond = this.bondFills[i];\n            bond.receiveShadow = value;\n            bond.castShadow = value;\n            bond.material.needsUpdate = true;\n        }\n        // For some reason double rendering is required... Maybe delay()?\n        this.render();\n        this.render();\n    }\n    /**\n     * Visualizes the given atomic structure.\n     *\n     * @param {object} structure A Javascript object containing the structure. See\n     *   below for the subparameters.\n     * @param {number[][]} structure.positions Atomic positions. Default\n     *   interpretation is as cartesian positions, but you can specify whether they\n     *   are cartesial or fractional with the \"fractional\" attribute.\n     * @param {boolean} structure.fractional Whether the given positions are\n     *   fractional or not. Defaults to false if not specified.\n     * @param {string[]|number[]} structure.species Atomic numbers or chemical symbols of the atoms.\n     * @param {number[]} structure.cell The lattice vectors of the unit cell as\n     *   rows of a 3x3 array.\n     * @param {boolean[]} structure.pbc The periodic boundary conditions for\n     *   the structure as a list of three boolean values for each lattice\n     *   vector direction.\n     * @param {number[][]} structure.bonds Optional manually set bonds. Provide a\n     *   list of atomic index pairs, each pair specifying a bond between atoms.\n     *   If these bonds are not specified, the visualizer will by default use an\n     *   automated detection of bonds. This can be disabled through\n     *   options.bonds.enabled.\n     */\n    load(structure) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n        // Deep copy the structure for reloading\n        this.structure = structure;\n        // Clear all the old data\n        this.clear();\n        this.setup();\n        // Reconstruct the visualization\n        this.setupScenes();\n        this.setupLights();\n        this.setupCamera();\n        this.setupControls();\n        // Determine the radii to be used\n        if (this.options.atoms.radii === \"covalent\") {\n            this.atomicRadii = this.covalentRadii;\n        }\n        else if (Array.isArray(this.options.atoms.radii)) {\n            this.atomicRadii = this.options.atoms.radii;\n        }\n        // Determine the atom colors to be used\n        if (this.options.atoms.colors === \"Jmol\") {\n            this.elementColors = this.jmolColors;\n        }\n        else if (Array.isArray(this.options.atoms.colors)) {\n            this.elementColors = this.options.atoms.colors;\n        }\n        // Check that the received data is OK.\n        let isFractional = structure[\"fractional\"] === undefined ? false : structure[\"fractional\"];\n        let positions = structure[\"positions\"];\n        let species = structure[\"species\"];\n        let cell = structure[\"cell\"];\n        let periodicity = structure[\"pbc\"];\n        let bonds = structure[\"bonds\"];\n        if (!positions) {\n            console.log(\"No atom positions given to the structure viewer\");\n            return false;\n        }\n        if (!species) {\n            console.log(\"No species  given to the structure viewer.\");\n            return false;\n        }\n        // Determine the atomicNumbers if not given\n        let atomicNumbers = typeof species[0] === \"number\" ? species : species.map(symb => {\n            return this.elementNumbers[symb];\n        });\n        // If bonds are not explicitly stated, determine them automatically.\n        if (!bonds) {\n            bonds = \"auto\";\n        }\n        else {\n            if (!Array.isArray(bonds)) {\n                console.log(\"Invalid value for 'bonds'. Provide a list of index pairs.\");\n                return false;\n            }\n        }\n        if (positions.length != atomicNumbers.length) {\n            console.log(\"The number of positions does not match the number of labels.\");\n            return false;\n        }\n        // Assume no periodicity if not defined\n        if ((periodicity == undefined) || (periodicity == null)) {\n            periodicity = [false, false, false];\n        }\n        this.root = new three__WEBPACK_IMPORTED_MODULE_1__[\"Object3D\"]();\n        this.container = new three__WEBPACK_IMPORTED_MODULE_1__[\"Object3D\"]();\n        this.infoContainer = new three__WEBPACK_IMPORTED_MODULE_1__[\"Object3D\"]();\n        this.atoms = new three__WEBPACK_IMPORTED_MODULE_1__[\"Object3D\"]();\n        this.bonds = new three__WEBPACK_IMPORTED_MODULE_1__[\"Object3D\"]();\n        this.container.add(this.atoms);\n        this.container.add(this.bonds);\n        this.angleArcs = new three__WEBPACK_IMPORTED_MODULE_1__[\"Object3D\"]();\n        this.root.add(this.container);\n        this.sceneStructure.add(this.root);\n        this.sceneInfo.add(this.infoContainer);\n        this.latticeConstants = new three__WEBPACK_IMPORTED_MODULE_1__[\"Object3D\"]();\n        this.container.add(this.latticeConstants);\n        // Create a set of fractional and cartesian positions\n        this.createBasisVectors(cell);\n        let fracPos = [];\n        let cartPos = [];\n        // Create a set of fractional and cartesian positions\n        if (isFractional === true) {\n            for (let i = 0; i < positions.length; ++i) {\n                let pos = positions[i];\n                let iFracPos = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().fromArray(pos);\n                fracPos.push(iFracPos);\n                cartPos.push(this.toCartesian(iFracPos));\n            }\n        }\n        else if (isFractional === false) {\n            for (let i = 0; i < positions.length; ++i) {\n                let pos = positions[i];\n                let iCartPos = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().fromArray(pos);\n                cartPos.push(iCartPos);\n            }\n            if (this.B !== undefined) {\n                for (let i = 0, size = cartPos.length; i < size; ++i) {\n                    let iFracPos = this.toScaled(cartPos[i]);\n                    fracPos.push(iFracPos);\n                }\n            }\n        }\n        // Determine the periodicity and setup the vizualization accordingly\n        let nPeriodic = 0;\n        let periodicIndices = [];\n        let p1 = periodicity[0];\n        let p2 = periodicity[1];\n        let p3 = periodicity[2];\n        if (p1 && p2 && p3) {\n            nPeriodic = 3;\n        }\n        else if (!p1 && !p2 && !p3) {\n            nPeriodic = 0;\n        }\n        else {\n            for (let dim = 0; dim < 3; ++dim) {\n                let p1 = periodicity[dim];\n                let p2 = periodicity[(dim + 1) % 3];\n                let p3 = periodicity[(dim + 2) % 3];\n                if (p1 && !p2 && !p3) {\n                    nPeriodic = 1;\n                    periodicIndices.push(dim);\n                    break;\n                }\n                else if (p1 && p2 && !p3) {\n                    nPeriodic = 2;\n                    periodicIndices.push(dim);\n                    periodicIndices.push((dim + 1) % 3);\n                    break;\n                }\n            }\n        }\n        if (this.B !== undefined) {\n            this.createConventionalCell(periodicity, this.options.cell.enabled);\n            this.createLatticeConstants(this.basisVectors, periodicity, periodicIndices);\n            this.createAtoms(fracPos, atomicNumbers, periodicity, true);\n        }\n        else {\n            this.createAtoms(cartPos, atomicNumbers, periodicity, false);\n        }\n        let atomPos = this.getPositions();\n        // Determine the corner points that are used to properly fit the\n        // structure into the viewer. The fit takes also into account the\n        // periodic duplicates and atoms created at the boundary.\n        this.createVisualizationBoundaryPositions(atomPos, atomicNumbers);\n        // Create bonds\n        this.createBonds(bonds);\n        // Setup the view center\n        let viewCenter = this.options.layout.viewCenter;\n        let centerPos;\n        // Center of positions takes into account also the repeated positions\n        // and positions created at the cell boundaries.\n        if (viewCenter === \"COP\") {\n            centerPos = this.calculateCOP(atomPos);\n        }\n        else if (viewCenter === \"COC\") {\n            centerPos = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]()\n                .add(this.basisVectors[0])\n                .add(this.basisVectors[1])\n                .add(this.basisVectors[2])\n                .multiplyScalar(0.5);\n        }\n        else if (Array.isArray(viewCenter)) {\n            centerPos = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().fromArray(viewCenter);\n        }\n        this.setViewCenter(centerPos);\n        // Translate the system according to given option\n        this.translate(this.options.layout.translation);\n        // Zoom according to given option\n        this.setZoom(this.options.controls.zoomLevel);\n        // Set view alignment and rotation\n        if (this.B !== undefined) {\n            this.alignView((_d = (_c = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.layout) === null || _b === void 0 ? void 0 : _b.viewRotation) === null || _c === void 0 ? void 0 : _c.align) === null || _d === void 0 ? void 0 : _d.top, (_h = (_g = (_f = (_e = this.options) === null || _e === void 0 ? void 0 : _e.layout) === null || _f === void 0 ? void 0 : _f.viewRotation) === null || _g === void 0 ? void 0 : _g.align) === null || _h === void 0 ? void 0 : _h.right);\n        }\n        this.rotateView((_l = (_k = (_j = this.options) === null || _j === void 0 ? void 0 : _j.layout) === null || _k === void 0 ? void 0 : _k.viewRotation) === null || _l === void 0 ? void 0 : _l.rotations);\n        if (this.options.view.autoFit) {\n            this.fitToCanvas();\n        }\n        this.toggleShadows(this.options.renderer.shadows.enabled);\n        this.render();\n        return true;\n    }\n    /**\n     *\n     */\n    calculateCOP(positions) {\n        let nPos = positions.length;\n        let sum = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]();\n        for (let i = 0; i < nPos; ++i) {\n            let pos = positions[i];\n            sum.add(pos);\n        }\n        sum.divideScalar(nPos);\n        return sum;\n    }\n    /**\n     * Centers the visualization around a specific point.\n     * @param centerPos - The center position as a cartesian vector.\n     */\n    setViewCenter(centerPos) {\n        this.container.position.sub(centerPos);\n        this.infoContainer.position.sub(centerPos);\n        this.render();\n    }\n    /**\n     * Translate the atoms.\n     *\n     * @param translation - Cartesian translation to apply.\n     */\n    translate(translation) {\n        let vec = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().fromArray(translation);\n        this.atoms.position.add(vec);\n        this.bonds.position.add(vec);\n        this.render();\n    }\n    /**\n     * Set the position for atoms in the currently loaded structure.\n     */\n    setPositions(positions, fractional = false, render = true) {\n        // Check the periodicity setting. You can only call this function if no\n        // additional atoms need to be created through the periodicity setting.\n        if (this.options.layout.periodicity !== \"none\") {\n            throw \"Setting new positions is only allowed if options.layout.periodicity = 'none'.\";\n        }\n        if (fractional) {\n            for (let i = 0, size = positions.length; i < size; ++i) {\n                let atom = this.getAtom(i);\n                let position = this.toCartesian(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().fromArray(positions[i]));\n                atom.position.copy(position);\n            }\n        }\n        else {\n            for (let i = 0, size = positions.length; i < size; ++i) {\n                let atom = this.getAtom(i);\n                let position = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().fromArray(positions[i]);\n                atom.position.copy(position);\n            }\n        }\n        this.updateBonds = true;\n        this.createBonds();\n        if (render) {\n            this.render();\n        }\n    }\n    /**\n     * Set the position for atoms in the currently loaded structure.\n     */\n    getPositions(fractional = false) {\n        let positions = [];\n        let atoms = this.atoms.children;\n        let nAtoms = atoms.length;\n        if (fractional) {\n            for (let i = 0; i < nAtoms; ++i) {\n                let atom = atoms[i];\n                let position = this.toScaled(atom.position.clone());\n                positions.push(position);\n            }\n        }\n        else {\n            for (let i = 0; i < nAtoms; ++i) {\n                let atom = atoms[i];\n                let position = atom.position.clone();\n                positions.push(position);\n            }\n        }\n        return positions;\n    }\n    toCartesian(position) {\n        return position.clone().applyMatrix3(this.B);\n    }\n    toScaled(position) {\n        return position.clone().applyMatrix3(this.Bi);\n    }\n    /**\n     * Get a specific atom as defined by a THREE.js Group.\n     *\n     * @param index - Index of the atom.\n     *\n     * @return THREE.js Group containing the visuals for the atom. The position\n     * of the atom is determined by the position of the group.\n     */\n    getAtom(index) {\n        return this.atoms.getObjectByName(`atom${index}`);\n    }\n    /**\n     * Set the zoom level\n     *\n     * @param zoomLevel - The zoom level as a scalar.\n     */\n    setZoom(zoomLevel) {\n        this.camera.zoom = zoomLevel;\n        this.render();\n    }\n    setupLights() {\n        this.lights = [];\n        let shadowMapWidth = 2048;\n        // Key light\n        let keyLight = new three__WEBPACK_IMPORTED_MODULE_1__[\"DirectionalLight\"](0xffffff, 0.45);\n        keyLight.shadow.mapSize.width = shadowMapWidth;\n        keyLight.shadow.mapSize.height = shadowMapWidth;\n        keyLight.position.set(0, 0, 20);\n        this.sceneStructure.add(keyLight);\n        this.lights.push(keyLight);\n        // Fill light\n        let fillLight = new three__WEBPACK_IMPORTED_MODULE_1__[\"DirectionalLight\"](0xffffff, 0.3);\n        fillLight.shadow.mapSize.width = shadowMapWidth;\n        fillLight.shadow.mapSize.height = shadowMapWidth;\n        fillLight.position.set(-20, 0, -20);\n        this.sceneStructure.add(fillLight);\n        this.lights.push(fillLight);\n        // Back light\n        let backLight = new three__WEBPACK_IMPORTED_MODULE_1__[\"DirectionalLight\"](0xffffff, 0.25);\n        backLight.shadow.mapSize.width = shadowMapWidth;\n        backLight.shadow.mapSize.height = shadowMapWidth;\n        backLight.position.set(20, 0, -20);\n        //backLight.position.set( 0, 0, -20 );\n        this.sceneStructure.add(backLight);\n        this.lights.push(backLight);\n        // White ambient light.\n        let ambientLight = new three__WEBPACK_IMPORTED_MODULE_1__[\"AmbientLight\"](0x404040, 1.7); // soft white light\n        this.sceneStructure.add(ambientLight);\n    }\n    /**\n     * Create the visuals to show the lattice parameter labels.\n     */\n    createLatticeConstants(basis, periodicity, periodicIndices) {\n        if (!this.options.latticeConstants.enabled) {\n            return;\n        }\n        this.axisLabels = [];\n        this.infoContainer.add(this.latticeConstants);\n        this.infoContainer.add(this.angleArcs);\n        let infoColor = 0x000000;\n        // Used to create a text label as sprite that lives in 3D space.\n        let createLabel = (position, label, color, stroked = true, fontFamily, fontSize) => {\n            // Configure canvas\n            let canvas = document.createElement('canvas');\n            let size = 256;\n            canvas.width = size;\n            canvas.height = size;\n            let ctx = canvas.getContext('2d');\n            // Draw label\n            ctx.fillStyle = color;\n            ctx.font = `${0.90 * size}px ${fontFamily}`;\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            if (stroked) {\n                ctx.lineWidth = 0.06 * size;\n                ctx.strokeStyle = \"#000000\";\n                ctx.strokeText(label, size / 2, size / 2);\n            }\n            ctx.fillText(label, size / 2, size / 2);\n            let texture = new three__WEBPACK_IMPORTED_MODULE_1__[\"Texture\"](canvas);\n            texture.needsUpdate = true;\n            let material = new three__WEBPACK_IMPORTED_MODULE_1__[\"SpriteMaterial\"]({ map: texture });\n            let sprite = new three__WEBPACK_IMPORTED_MODULE_1__[\"Sprite\"](material);\n            sprite.scale.set(fontSize, fontSize, 1);\n            let labelRoot = new three__WEBPACK_IMPORTED_MODULE_1__[\"Object3D\"]();\n            labelRoot.position.copy(position);\n            labelRoot.add(sprite);\n            return labelRoot;\n        };\n        let axisMaterial = new three__WEBPACK_IMPORTED_MODULE_1__[\"LineBasicMaterial\"]({\n            color: \"#000000\",\n            linewidth: 1.5\n        });\n        let axisOffset = 1.3;\n        let iBasis = -1;\n        let cellBasisColors = [];\n        cellBasisColors.push(this.options.latticeConstants.a.color);\n        cellBasisColors.push(this.options.latticeConstants.b.color);\n        cellBasisColors.push(this.options.latticeConstants.c.color);\n        let angleColors = [];\n        angleColors.push(this.options.latticeConstants.alpha.color);\n        angleColors.push(this.options.latticeConstants.beta.color);\n        angleColors.push(this.options.latticeConstants.gamma.color);\n        let angleLabels = [this.options.latticeConstants.gamma.label, this.options.latticeConstants.alpha.label, this.options.latticeConstants.beta.label];\n        let axisLabels = [this.options.latticeConstants.a.label, this.options.latticeConstants.b.label, this.options.latticeConstants.c.label];\n        let angleEnableds = [this.options.latticeConstants.gamma.enabled, this.options.latticeConstants.alpha.enabled, this.options.latticeConstants.beta.enabled];\n        let axisEnableds = [this.options.latticeConstants.a.enabled, this.options.latticeConstants.b.enabled, this.options.latticeConstants.c.enabled];\n        let axisFonts = [];\n        axisFonts.push(this.options.latticeConstants.a.font === undefined ? this.options.latticeConstants.font : this.options.latticeConstants.a.font);\n        axisFonts.push(this.options.latticeConstants.b.font === undefined ? this.options.latticeConstants.font : this.options.latticeConstants.b.font);\n        axisFonts.push(this.options.latticeConstants.c.font === undefined ? this.options.latticeConstants.font : this.options.latticeConstants.c.font);\n        let axisFontSizes = [];\n        axisFontSizes.push(this.options.latticeConstants.a.size === undefined ? this.options.latticeConstants.size : this.options.latticeConstants.a.size);\n        axisFontSizes.push(this.options.latticeConstants.b.size === undefined ? this.options.latticeConstants.size : this.options.latticeConstants.b.size);\n        axisFontSizes.push(this.options.latticeConstants.c.size === undefined ? this.options.latticeConstants.size : this.options.latticeConstants.c.size);\n        let angleFonts = [];\n        angleFonts.push(this.options.latticeConstants.alpha.font === undefined ? this.options.latticeConstants.font : this.options.latticeConstants.alpha.font);\n        angleFonts.push(this.options.latticeConstants.beta.font === undefined ? this.options.latticeConstants.font : this.options.latticeConstants.beta.font);\n        angleFonts.push(this.options.latticeConstants.gamma.font === undefined ? this.options.latticeConstants.font : this.options.latticeConstants.gamma.font);\n        let angleFontSizes = [];\n        angleFontSizes.push(this.options.latticeConstants.alpha.size === undefined ? this.options.latticeConstants.size : this.options.latticeConstants.alpha.size);\n        angleFontSizes.push(this.options.latticeConstants.beta.size === undefined ? this.options.latticeConstants.size : this.options.latticeConstants.beta.size);\n        angleFontSizes.push(this.options.latticeConstants.gamma.size === undefined ? this.options.latticeConstants.size : this.options.latticeConstants.gamma.size);\n        let axisLabelSprites = [];\n        let angleLabelSprites = [];\n        // If 2D periodic, we save the periodic indices, and ensure a right\n        // handed coordinate system.\n        let first;\n        let second;\n        for (let iTrueBasis = 0; iTrueBasis < 3; ++iTrueBasis) {\n            iBasis += 1;\n            let axisLabel = axisLabels[iBasis];\n            let axisColor = cellBasisColors[iBasis];\n            let axisFont = axisFonts[iBasis];\n            let axisFontSize = axisFontSizes[iBasis];\n            let angleFontSize = angleFontSizes[iBasis];\n            let angleFont = angleFonts[iBasis];\n            let angleColor = angleColors[iBasis];\n            let angleLabel = angleLabels[iBasis];\n            let axisEnabled = axisEnableds[iBasis];\n            let angleEnabled = angleEnableds[iBasis];\n            let basisVec1 = basis[iTrueBasis];\n            let basisVec2 = basis[(iTrueBasis + 1) % 3].clone();\n            let basisVec3 = basis[(iTrueBasis + 2) % 3].clone();\n            if (axisEnabled) {\n                // Basis and angle label selection, same for all systems\n                let origin = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 0, 0);\n                let dir = basisVec1.clone();\n                // Add an axis label\n                let textPos = dir.clone()\n                    .multiplyScalar(0.5);\n                let labelOffset;\n                let newBasis2;\n                let newBasis3;\n                if (basisVec2.length() == 0) {\n                    newBasis2 = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().crossVectors(basisVec1, basisVec3);\n                    labelOffset = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().crossVectors(basisVec1, newBasis2);\n                }\n                else if (basisVec3.length() == 0) {\n                    newBasis3 = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().crossVectors(basisVec1, basisVec2);\n                    labelOffset = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().crossVectors(basisVec1, basisVec3);\n                }\n                else {\n                    let labelOffset1 = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().crossVectors(basisVec1, basisVec2);\n                    let labelOffset2 = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().crossVectors(basisVec1, basisVec3);\n                    labelOffset = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().sub(labelOffset1).add(labelOffset2);\n                }\n                labelOffset.normalize();\n                labelOffset.multiplyScalar(0.8);\n                textPos.add(labelOffset);\n                let axisLabelSprite = createLabel(textPos, axisLabel, axisColor, true, axisFont, axisFontSize);\n                this.latticeConstants.add(axisLabelSprite);\n                this.axisLabels.push(axisLabelSprite);\n                // Add basis vector colored line\n                let cellVectorMaterial = new three__WEBPACK_IMPORTED_MODULE_1__[\"MeshBasicMaterial\"]({\n                    color: axisColor,\n                    transparent: true,\n                    opacity: 0.75\n                });\n                let cellVector = basisVec1.clone();\n                let cellVectorLine = this.createCylinder(origin.clone(), cellVector.clone().add(origin), 0.09, 10, cellVectorMaterial);\n                this.latticeConstants.add(cellVectorLine);\n                // Add basis vector axis line\n                let cellAxisMaterial = new three__WEBPACK_IMPORTED_MODULE_1__[\"MeshBasicMaterial\"]({\n                    color: \"#000000\",\n                });\n                let axisStart = this.basisVectors[iTrueBasis].clone();\n                let axisEnd = axisStart.clone().multiplyScalar(1 + axisOffset / axisStart.length());\n                let cellAxisVector = basisVec1.clone();\n                let cellAxisVectorLine = this.createCylinder(origin.clone(), axisEnd, 0.02, 10, cellAxisMaterial);\n                this.latticeConstants.add(cellAxisVectorLine);\n                // Add axis arrow\n                let arrowGeometry = new three__WEBPACK_IMPORTED_MODULE_1__[\"CylinderGeometry\"](0, 0.10, 0.5, 12);\n                let arrowMaterial = new three__WEBPACK_IMPORTED_MODULE_1__[\"MeshBasicMaterial\"]({\n                    color: infoColor,\n                });\n                let arrow = new three__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"](arrowGeometry, arrowMaterial);\n                arrow.position.copy(dir)\n                    .multiplyScalar(1 + axisOffset / dir.length());\n                arrow.lookAt(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]());\n                arrow.rotateX(-Math.PI / 2);\n                this.latticeConstants.add(arrow);\n            }\n            if (angleEnabled) {\n                // Add angle label and curve\n                let arcMaterial = new three__WEBPACK_IMPORTED_MODULE_1__[\"LineDashedMaterial\"]({\n                    color: infoColor,\n                    linewidth: 2,\n                    dashSize: 0.2,\n                    gapSize: 0.1\n                });\n                let normal = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().crossVectors(basisVec1, basisVec2);\n                let angle = basisVec1.angleTo(basisVec2);\n                let radius = Math.max(Math.min(1 / 4 * basisVec1.length(), 1 / 4 * basisVec2.length()), 1);\n                let curve = new three__WEBPACK_IMPORTED_MODULE_1__[\"EllipseCurve\"](0, 0, // ax, aY\n                radius, radius, // xRadius, yRadius\n                0, angle, // aStartAngle, aEndAngle\n                false, // aClockwise\n                0 // aRotation\n                );\n                let points = curve.getSpacedPoints(20);\n                let arcGeometry = new three__WEBPACK_IMPORTED_MODULE_1__[\"Geometry\"]().setFromPoints(points);\n                let arc = new three__WEBPACK_IMPORTED_MODULE_1__[\"Line\"](arcGeometry, arcMaterial);\n                arc.computeLineDistances();\n                // First rotate the arc so that it's x-axis points towards the\n                // first basis vector that defines the arc\n                let yAxis = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 1, 0);\n                let xAxis = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](1, 0, 0);\n                let zAxis = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 0, 1);\n                let quaternion = new three__WEBPACK_IMPORTED_MODULE_1__[\"Quaternion\"]().setFromUnitVectors(xAxis, basisVec1.clone().normalize());\n                arc.quaternion.copy(quaternion);\n                // Then rotate the arc along it's x axis so that the xy-plane\n                // coincides with the plane defined by the the two basis vectors\n                // that define the plane.\n                let lastArcPointLocal = arcGeometry.vertices[arcGeometry.vertices.length - 1];\n                arc.updateMatrixWorld(); // The positions are not otherwise updated properly\n                let lastArcPointWorld = arc.localToWorld(lastArcPointLocal.clone());\n                // The angle direction is defined by the first basis vector\n                let axis = basisVec1;\n                let arcNormal = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]()\n                    .crossVectors(axis, lastArcPointWorld);\n                let planeAngle = normal.angleTo(arcNormal);\n                let planeCross = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]()\n                    .crossVectors(basisVec2, lastArcPointWorld);\n                let directionValue = planeCross.dot(axis);\n                if (directionValue > 0) {\n                    planeAngle = -planeAngle;\n                }\n                arc.rotateX(planeAngle);\n                // Add label for the angle\n                arc.updateMatrixWorld(); // The positions are not otherwise updated properly\n                arc.updateMatrix(); // The positions are not otherwise updated properly\n                let angleLabelPos = arc.localToWorld(arcGeometry.vertices[9].clone());\n                let angleLabelLen = angleLabelPos.length();\n                angleLabelPos.multiplyScalar(1 + 0.3 / angleLabelLen);\n                let angleLabelObj = createLabel(angleLabelPos, angleLabel.toString(), angleColor, true, angleFont, angleFontSize);\n                this.latticeConstants.add(angleLabelObj);\n                this.axisLabels.push(angleLabelObj);\n                this.angleArcs.add(arc);\n            }\n        }\n    }\n    /**\n     * Creates a list of THREE.Vector3s from the given list of arrays.\n     *\n     * @param vectors - The positions from which to create vectors.\n     */\n    createBasisVectors(basis) {\n        if (basis === undefined) {\n            return undefined;\n        }\n        // Create basis transformation matrices\n        let a = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().fromArray(basis[0]);\n        let b = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().fromArray(basis[1]);\n        let c = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().fromArray(basis[2]);\n        this.basisVectors = [a, b, c];\n        let B = new three__WEBPACK_IMPORTED_MODULE_1__[\"Matrix3\"]();\n        B.set(a.x, b.x, c.x, a.y, b.y, c.y, a.z, b.z, c.z);\n        this.B = B;\n        this.Bi = new three__WEBPACK_IMPORTED_MODULE_1__[\"Matrix3\"]().getInverse(B);\n    }\n    createVisualizationBoundaryPositions(positions, atomicNumbers) {\n        // Determine the maximum and minimum values in all cartesian components\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n        let maxZ = -Infinity;\n        let minX = Infinity;\n        let minY = Infinity;\n        let minZ = Infinity;\n        let maxRadii = 0;\n        for (let len = positions.length, i = 0; i < len; ++i) {\n            let iPos = positions[i];\n            let iX = iPos.x;\n            if (iX > maxX) {\n                maxX = iX;\n            }\n            if (iX < minX) {\n                minX = iX;\n            }\n            let iY = iPos.y;\n            if (iY > maxY) {\n                maxY = iY;\n            }\n            if (iY < minY) {\n                minY = iY;\n            }\n            let iZ = iPos.z;\n            if (iZ > maxZ) {\n                maxZ = iZ;\n            }\n            if (iZ < minZ) {\n                minZ = iZ;\n            }\n            // Determine maximum radius that will be added to the visualization boundaries\n            let iRadius = this.atomicRadii[atomicNumbers[i]];\n            if (iRadius > maxRadii) {\n                maxRadii = iRadius;\n            }\n        }\n        // Add max atomic radii to boundaries\n        // Push the corners of the cuboid as cornerpoints\n        let origin = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](minX - maxRadii, minY - maxRadii, minZ - maxRadii);\n        let basisX = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](maxX - minX + 2 * maxRadii, 0, 0);\n        let basisY = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, maxY - minY + 2 * maxRadii, 0);\n        let basisZ = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 0, maxZ - minZ + 2 * maxRadii);\n        let basis = [basisX, basisY, basisZ];\n        // Get cuboid\n        let pointGeometry = this.createCornerPoints(origin, basis);\n        let points = new three__WEBPACK_IMPORTED_MODULE_1__[\"Points\"](pointGeometry);\n        points.visible = false;\n        this.cornerPoints = points;\n        // Must add the point to root because otherwise they will not be\n        // included in the transforms.\n        this.container.add(this.cornerPoints);\n    }\n    createVisualizationBoundaryCell(origin, basis) {\n        // Get cuboid\n        let pointGeometry = this.createCornerPoints(origin, basis);\n        let points = new three__WEBPACK_IMPORTED_MODULE_1__[\"Points\"](pointGeometry);\n        points.visible = false;\n        this.cornerPoints = points;\n        // Must add the point to root because otherwise they will not be\n        // included in the transforms.\n        this.container.add(this.cornerPoints);\n    }\n    /**\n     * Create the conventional cell\n     *\n     */\n    createConventionalCell(periodicity, visible) {\n        let cell = this.createCell(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](), this.basisVectors, periodicity, this.options.cell.color, this.options.cell.linewidth, this.options.cell.dashSize, this.options.cell.gapSize);\n        cell.visible = visible;\n        this.convCell = cell;\n        this.container.add(this.convCell);\n    }\n    /**\n     * Creates outlines for a cell specified by the given basis vectors.\n     * @param origin - The origin for the cell\n     * @param basisVectors - The cell basis vectors\n     * @param periodicity - The periodicity of the cell\n     * @param color - Color fo the cell wireframe\n     * @param linewidth - Line width fo the wireframe\n     * @param dashed - Is wireframe dashed\n     */\n    createCell(origin, basisVectors, periodicity, color, linewidth, dashSize, gapSize) {\n        let nonPeriodic;\n        let cell = new three__WEBPACK_IMPORTED_MODULE_1__[\"Object3D\"]();\n        let lineMaterial;\n        if (!(dashSize === 0 && gapSize === 0)) {\n            lineMaterial = new three__WEBPACK_IMPORTED_MODULE_1__[\"LineDashedMaterial\"]({\n                color: color,\n                linewidth: linewidth,\n                dashSize: dashSize,\n                gapSize: gapSize\n            });\n        }\n        else {\n            lineMaterial = new three__WEBPACK_IMPORTED_MODULE_1__[\"LineBasicMaterial\"]({\n                color: color,\n                linewidth: linewidth\n            });\n        }\n        /*\n        let dimMaterial = new THREE.LineDashedMaterial({\n            color: color,\n            linewidth: linewidth,\n            dashSize: dashSize,\n            gapSize: gapSize\n        });\n        */\n        // Determine the if one of the cell vectors is a zero vector\n        let collapsed = true;\n        for (let i = 0; i < 3; ++i) {\n            let vec = basisVectors[i];\n            let len = vec.length();\n            if (len > 1E-3 && !periodicity[i]) {\n                collapsed = false;\n            }\n        }\n        for (let len = basisVectors.length, i = 0; i < len; ++i) {\n            let basisVector = basisVectors[i].clone();\n            // First line\n            let line1Mat = lineMaterial.clone();\n            let isDim1 = !periodicity[i];\n            if (!(isDim1 && collapsed)) {\n                /*\n                if (isDim1) {\n                    line1Mat = dimMaterial.clone();\n                }\n                */\n                let lineGeometry = new three__WEBPACK_IMPORTED_MODULE_1__[\"Geometry\"]();\n                lineGeometry.vertices.push(origin.clone(), basisVector.clone().add(origin));\n                let line = new three__WEBPACK_IMPORTED_MODULE_1__[\"Line\"](lineGeometry, line1Mat);\n                cell.add(line);\n                line.computeLineDistances();\n            }\n            // Second line\n            let secondIndex = (i + 1) % len;\n            let secondAddition = basisVectors[secondIndex].clone();\n            let isDim2 = !periodicity[i] || !periodicity[(i + 1) % 3];\n            if (!(isDim2 && collapsed)) {\n                let line2Mat = lineMaterial.clone();\n                /*\n                if (isDim2) {\n                    line2Mat = dimMaterial.clone();\n                }\n                */\n                let line2Geometry = new three__WEBPACK_IMPORTED_MODULE_1__[\"Geometry\"]();\n                line2Geometry.vertices.push(secondAddition.clone().add(origin), basisVector.clone().add(secondAddition).add(origin));\n                let line2 = new three__WEBPACK_IMPORTED_MODULE_1__[\"Line\"](line2Geometry, line2Mat);\n                cell.add(line2);\n                line2.computeLineDistances();\n            }\n            // Third line\n            let thirdIndex = (i + 2) % len;\n            let thirdAddition = basisVectors[thirdIndex].clone();\n            let isDim3 = !periodicity[i] || !periodicity[(i + 2) % 3];\n            if (!(isDim3 && collapsed)) {\n                let line3Mat = lineMaterial.clone();\n                /*\n                if (isDim3) {\n                    line3Mat = dimMaterial.clone();\n                }\n                */\n                let line3Geometry = new three__WEBPACK_IMPORTED_MODULE_1__[\"Geometry\"]();\n                line3Geometry.vertices.push(thirdAddition.clone().add(origin), basisVector.clone().add(thirdAddition).add(origin));\n                let line3 = new three__WEBPACK_IMPORTED_MODULE_1__[\"Line\"](line3Geometry, line3Mat);\n                cell.add(line3);\n                line3.computeLineDistances();\n            }\n            // Fourth line\n            let isDim4 = !periodicity[i] || !periodicity[(i + 2) % 3] || !periodicity[(i + 1) % 3];\n            if (!(isDim4 && collapsed)) {\n                let line4Mat = lineMaterial.clone();\n                /*\n                if (isDim4) {\n                    line4Mat = dimMaterial.clone();\n                }\n                */\n                let line4Geometry = new three__WEBPACK_IMPORTED_MODULE_1__[\"Geometry\"]();\n                line4Geometry.vertices.push(secondAddition.clone().add(thirdAddition).add(origin), basisVector.clone().add(secondAddition).add(thirdAddition).add(origin));\n                let line4 = new three__WEBPACK_IMPORTED_MODULE_1__[\"Line\"](line4Geometry, line4Mat);\n                cell.add(line4);\n                line4.computeLineDistances();\n            }\n        }\n        return cell;\n    }\n    /**\n     * @param rotations The rotations as a list. Each rotation should be an\n     * array containing four numbers: [x, y, z, angle]. The rotations are\n     * applied in the given order.\n     */\n    rotateView(rotations, render = true) {\n        if (rotations === undefined) {\n            return;\n        }\n        for (let r of rotations) {\n            let basis = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](r[0], r[1], r[2]);\n            basis.normalize();\n            let angle = r[3] / 180 * Math.PI;\n            this.rotateAroundWorldAxis(this.root, basis, angle);\n            this.rotateAroundWorldAxis(this.sceneInfo, basis, angle);\n        }\n        if (render) {\n            this.render();\n        }\n    }\n    alignView(top, right, render = true) {\n        if (top === undefined) {\n            return;\n        }\n        // Determine the top direction\n        let topVector;\n        if (top === \"c\") {\n            topVector = this.basisVectors[2];\n        }\n        else if (top === \"-c\") {\n            topVector = this.basisVectors[2].negate();\n        }\n        else if (top === \"b\") {\n            topVector = this.basisVectors[1];\n        }\n        else if (top === \"-b\") {\n            topVector = this.basisVectors[1].negate();\n        }\n        else if (top === \"a\") {\n            topVector = this.basisVectors[0];\n        }\n        else if (top === \"-a\") {\n            topVector = this.basisVectors[0].negate();\n        }\n        // Determine the right direction\n        let rightVector;\n        if (right === \"c\") {\n            rightVector = this.basisVectors[2];\n        }\n        else if (right === \"-c\") {\n            rightVector = this.basisVectors[2].negate();\n        }\n        else if (right === \"b\") {\n            rightVector = this.basisVectors[1];\n        }\n        else if (right === \"-b\") {\n            rightVector = this.basisVectors[1].negate();\n        }\n        else if (right === \"a\") {\n            rightVector = this.basisVectors[0];\n        }\n        else if (right === \"-a\") {\n            rightVector = this.basisVectors[0].negate();\n        }\n        // Rotate so that the top vector points to top\n        this.root.updateMatrixWorld(); // The positions are not otherwise updated properly\n        let finalCAxis = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 1, 0);\n        let cQuaternion = new three__WEBPACK_IMPORTED_MODULE_1__[\"Quaternion\"]().setFromUnitVectors(topVector.clone().normalize(), finalCAxis);\n        this.root.quaternion.premultiply(cQuaternion);\n        this.sceneInfo.quaternion.premultiply(cQuaternion);\n        this.root.updateMatrixWorld();\n        this.sceneInfo.updateMatrixWorld();\n        // Rotate so that selected vector points to the right\n        if (right !== undefined) {\n            topVector = topVector.clone().applyQuaternion(cQuaternion);\n            rightVector = rightVector.clone().applyQuaternion(cQuaternion);\n            let currentAAxis = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().crossVectors(topVector, rightVector);\n            let finalAAxis = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 0, -1);\n            let aQuaternion = new three__WEBPACK_IMPORTED_MODULE_1__[\"Quaternion\"]().setFromUnitVectors(currentAAxis.clone().normalize(), finalAAxis);\n            this.root.quaternion.premultiply(aQuaternion);\n            this.sceneInfo.quaternion.premultiply(aQuaternion);\n            this.root.updateMatrixWorld();\n            this.sceneInfo.updateMatrixWorld();\n        }\n        if (render) {\n            this.render();\n        }\n    }\n    /**\n     * Used to add periodic repetitions of atoms.\n     */\n    repeat(multipliers, fracPos, labels) {\n        let a = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](1, 0, 0);\n        let b = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 1, 0);\n        let c = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 0, 1);\n        let newPos = [];\n        let newLabels = [];\n        for (let i = 0; i < multipliers[0]; ++i) {\n            for (let j = 0; j < multipliers[1]; ++j) {\n                for (let k = 0; k < multipliers[2]; ++k) {\n                    if (!(i == 0 && j == 0 && k == 0)) {\n                        // Add clone to the current coordinate\n                        let aTranslation = a.clone().multiplyScalar(i);\n                        let bTranslation = b.clone().multiplyScalar(j);\n                        let cTranslation = c.clone().multiplyScalar(k);\n                        // Add in front\n                        for (let l = 0, size = fracPos.length; l < size; ++l) {\n                            let iPos = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().copy(fracPos[l]);\n                            iPos.add(aTranslation);\n                            iPos.add(bTranslation);\n                            iPos.add(cTranslation);\n                            let iLabel = labels[l];\n                            newPos.push(iPos);\n                            newLabels.push(iLabel);\n                        }\n                    }\n                }\n            }\n        }\n        for (let i = 0; i < newPos.length; ++i) {\n            fracPos.push(newPos[i]);\n            labels.push(newLabels[i]);\n        }\n    }\n    /**\n     * Wraps all atoms to be within the unit cell.\n     */\n    wrap(fracPos, pbc) {\n        for (let len = fracPos.length, i = 0; i < len; ++i) {\n            let iFracPos = fracPos[i];\n            // Wrap the positions\n            let x = iFracPos.x;\n            let y = iFracPos.y;\n            let z = iFracPos.z;\n            if (pbc[0] && this.almostEqual(1, x, this.basisVectors[0], this.options.layout.wrapTolerance)) {\n                x -= 1;\n            }\n            if (pbc[1] && this.almostEqual(1, y, this.basisVectors[1], this.options.layout.wrapTolerance)) {\n                y -= 1;\n            }\n            if (pbc[2] && this.almostEqual(1, z, this.basisVectors[2], this.options.layout.wrapTolerance)) {\n                z -= 1;\n            }\n        }\n    }\n    /**\n     * Used to add periodic repetitions of atoms at the unit cell boundary.\n     */\n    addBoundaryAtoms(fracPos, labels) {\n        for (let len = fracPos.length, i = 0; i < len; ++i) {\n            let iFracPos = fracPos[i];\n            let atomicNumber = labels[i];\n            // If the atom sits on the cell surface, add the periodic images if\n            // requested.\n            let x = iFracPos.x;\n            let y = iFracPos.y;\n            let z = iFracPos.z;\n            let xZero = this.almostEqual(0, x, this.basisVectors[0], this.options.layout.wrapTolerance);\n            let yZero = this.almostEqual(0, y, this.basisVectors[1], this.options.layout.wrapTolerance);\n            let zZero = this.almostEqual(0, z, this.basisVectors[2], this.options.layout.wrapTolerance);\n            if (xZero && yZero && zZero) {\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](1, 0, 0).add(iFracPos));\n                labels.push(atomicNumber);\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 1, 0).add(iFracPos));\n                labels.push(atomicNumber);\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 0, 1).add(iFracPos));\n                labels.push(atomicNumber);\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](1, 1, 0).add(iFracPos));\n                labels.push(atomicNumber);\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 1, 1).add(iFracPos));\n                labels.push(atomicNumber);\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](1, 0, 1).add(iFracPos));\n                labels.push(atomicNumber);\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](1, 1, 1).add(iFracPos));\n                labels.push(atomicNumber);\n            }\n            else if (xZero && yZero && !zZero) {\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](1, 0, 0).add(iFracPos));\n                labels.push(atomicNumber);\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 1, 0).add(iFracPos));\n                labels.push(atomicNumber);\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](1, 1, 0).add(iFracPos));\n                labels.push(atomicNumber);\n            }\n            else if (!xZero && yZero && zZero) {\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 1, 0).add(iFracPos));\n                labels.push(atomicNumber);\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 0, 1).add(iFracPos));\n                labels.push(atomicNumber);\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 1, 1).add(iFracPos));\n                labels.push(atomicNumber);\n            }\n            else if (xZero && !yZero && zZero) {\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](1, 0, 0).add(iFracPos));\n                labels.push(atomicNumber);\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 0, 1).add(iFracPos));\n                labels.push(atomicNumber);\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](1, 0, 1).add(iFracPos));\n                labels.push(atomicNumber);\n            }\n            else if (xZero && !yZero && !zZero) {\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](1, 0, 0).add(iFracPos));\n                labels.push(atomicNumber);\n            }\n            else if (!xZero && yZero && !zZero) {\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 1, 0).add(iFracPos));\n                labels.push(atomicNumber);\n            }\n            else if (!xZero && !yZero && zZero) {\n                fracPos.push(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 0, 1).add(iFracPos));\n                labels.push(atomicNumber);\n            }\n        }\n    }\n    /**\n     * Creates representation for all the given atoms.\n     *\n     * @param positions - Positions of the atoms\n     * @param labels - The element numbers for the atoms\n     */\n    createAtoms(positions, labels, pbc, fractional = true) {\n        // Delete old atoms\n        this.atoms.remove(...this.atoms.children);\n        this.elements = {};\n        this.atomNumbers = [];\n        this.atomFills = [];\n        this.atomOutlines = [];\n        // Prepare variables\n        if (fractional) {\n            let basis1 = this.basisVectors[0];\n            let basis2 = this.basisVectors[1];\n            let basis3 = this.basisVectors[2];\n            // Determine the periodicity handling\n            if (pbc.some(a => { return a === true; })) {\n                let periodicity = this.options.layout.periodicity;\n                if (periodicity === \"none\") {\n                }\n                else if (periodicity === \"wrap\") {\n                    this.wrap(positions, pbc);\n                }\n                else if (periodicity === \"boundary\") {\n                    this.addBoundaryAtoms(positions, labels);\n                }\n                else if (Array.isArray(periodicity)) {\n                    this.repeat(periodicity, positions, labels);\n                }\n            }\n        }\n        // Create the 3D atoms at the correct positions\n        let meshMap = {};\n        for (let len = positions.length, i = 0; i < len; ++i) {\n            let iPos = positions[i];\n            // Add the primary atom\n            let atomicNumber = labels[i];\n            this.addAtom(i, iPos, atomicNumber, meshMap, fractional);\n            // Gather element legend data\n            let elementName = this.elementNames[atomicNumber - 1];\n            this.elements[elementName] = [this.elementColors[atomicNumber], this.atomicRadii[atomicNumber]];\n        }\n    }\n    /**\n     * Creates bonds between the atoms based on radii and distance.\n     *\n     * @param bonds - A Nx2 list of atom indices specifying the bonded atoms. Alternatively\n     *                you can use \"auto\" to automatically create the bonds.\n     */\n    createBonds(bonds = \"auto\") {\n        if (!this.options.bonds.enabled) {\n            return;\n        }\n        // See if the bonds need to be updated.\n        if (!this.updateBonds) {\n            return;\n        }\n        // Delete old bonds\n        this.bondFills = [];\n        this.bonds.remove(...this.bonds.children);\n        // Get current positions\n        let atomPos = this.getPositions();\n        // Manual bonds\n        if (Array.isArray(bonds)) {\n            for (let bond of bonds) {\n                let i = bond[0];\n                let j = bond[1];\n                let pos1 = atomPos[i];\n                let pos2 = atomPos[j];\n                this.addBond(i, j, pos1, pos2);\n            }\n            // Automatically detect bonds\n        }\n        else if (bonds === \"auto\") {\n            let nAtoms = atomPos.length;\n            for (let i = 0; i < nAtoms; ++i) {\n                for (let j = 0; j < nAtoms; ++j) {\n                    if (j > i) {\n                        let pos1 = atomPos[i];\n                        let pos2 = atomPos[j];\n                        let num1 = this.atomNumbers[i];\n                        let num2 = this.atomNumbers[j];\n                        let distance = pos2.clone().sub(pos1).length();\n                        let radii1 = this.options.atoms.scale * this.atomicRadii[num1];\n                        let radii2 = this.options.atoms.scale * this.atomicRadii[num2];\n                        if (distance <= this.options.bonds.threshold * 1.1 * (radii1 + radii2)) {\n                            this.addBond(i, j, pos1, pos2);\n                        }\n                    }\n                }\n            }\n        }\n        this.updateBonds = false;\n    }\n    /**\n     * Used to check if the given fractional position component is almost the\n     * given target value with a tolerance given in cartesian corodinates.\n     */\n    almostEqual(target, coordinate, basisVector, tolerance) {\n        let relDistance = (coordinate - target);\n        let absDistance = Math.abs(basisVector.clone().multiplyScalar(relDistance).length());\n        if (absDistance < tolerance) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Creates atom to the scene.\n     *\n     * @param position - Position of the atom\n     * @param atomicNumber - The atomic number for the added atom\n     * @param fractional - Are the coordinates relatice to the cell basis vectors\n     */\n    addBond(i, j, pos1, pos2) {\n        // Bond\n        let radius = this.options.bonds.radius;\n        let targetAngle = this.options.bonds.smoothness;\n        let nSegments = Math.ceil(360 / (180 - targetAngle));\n        let bondMaterial = new three__WEBPACK_IMPORTED_MODULE_1__[\"MeshPhongMaterial\"]({ color: 0xFFFFFF, shininess: this.options.bonds.material.shininess });\n        let cylinder = this.createCylinder(pos1, pos2, radius, nSegments, bondMaterial);\n        cylinder.name = \"fill\";\n        this.bondFills.push(cylinder);\n        // Put all bonds visuals inside a named group\n        let group = new three__WEBPACK_IMPORTED_MODULE_1__[\"Group\"]();\n        group.name = \"bond\" + i + \"-\" + j;\n        group.add(cylinder);\n        // Bond outline hack\n        if (this.options.outline.enabled) {\n            let addition = this.options.outline.size;\n            let scale = addition / radius + 1;\n            let outlineMaterial = new three__WEBPACK_IMPORTED_MODULE_1__[\"MeshBasicMaterial\"]({ color: this.options.outline.color, side: three__WEBPACK_IMPORTED_MODULE_1__[\"BackSide\"] });\n            let outline = this.createCylinder(pos1, pos2, scale * radius, 10, outlineMaterial);\n            outline.name = \"outline\";\n            group.add(outline);\n        }\n        this.bonds.add(group);\n    }\n    /**\n     * Creates atoms and directly adds themto the scene.\n     *\n     * @param position - Position of the atom\n     * @param atomicNumber - The atomic number for the added atom\n     * @param fractional - Are the coordinates relatice to the cell basis vectors\n     */\n    addAtom(index, position, atomicNumber, mesh, fractional = true) {\n        let exists = atomicNumber in mesh;\n        if (!exists) {\n            mesh[atomicNumber] = {};\n            // Calculate the amount of segments that are needed to reach a\n            // certain angle for the ball surface segments\n            let radius = this.options.atoms.scale * this.atomicRadii[atomicNumber];\n            let targetAngle = this.options.atoms.smoothness;\n            let nSegments = Math.ceil(360 / (180 - targetAngle));\n            // Atom\n            let color = this.elementColors[atomicNumber];\n            let atomGeometry = new three__WEBPACK_IMPORTED_MODULE_1__[\"SphereGeometry\"](radius, nSegments, nSegments);\n            let atomMaterial = new three__WEBPACK_IMPORTED_MODULE_1__[\"MeshPhongMaterial\"]({ color: color, shininess: this.options.atoms.material.shininess });\n            let atom = new three__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"](atomGeometry, atomMaterial);\n            mesh[atomicNumber].atom = atom;\n            // Atom outline hack\n            if (this.options.outline.enabled) {\n                let addition = this.options.outline.size;\n                let scale = addition / radius + 1;\n                let outlineGeometry = new three__WEBPACK_IMPORTED_MODULE_1__[\"SphereGeometry\"](radius * scale, nSegments, nSegments);\n                let outlineMaterial = new three__WEBPACK_IMPORTED_MODULE_1__[\"MeshBasicMaterial\"]({ color: this.options.outline.color, side: three__WEBPACK_IMPORTED_MODULE_1__[\"BackSide\"] });\n                let outline = new three__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"](outlineGeometry, outlineMaterial);\n                mesh[atomicNumber].outline = outline;\n            }\n        }\n        let imesh = mesh[atomicNumber];\n        let true_pos = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]();\n        if (fractional) {\n            true_pos.add(this.basisVectors[0].clone().multiplyScalar(position.x));\n            true_pos.add(this.basisVectors[1].clone().multiplyScalar(position.y));\n            true_pos.add(this.basisVectors[2].clone().multiplyScalar(position.z));\n        }\n        else {\n            true_pos.copy(position);\n        }\n        // Put all atoms visuals inside a named group\n        let group = new three__WEBPACK_IMPORTED_MODULE_1__[\"Group\"]();\n        group.name = \"atom\" + index;\n        let atom = imesh[\"atom\"].clone();\n        atom.name = \"fill\";\n        group.add(atom);\n        if (this.options.outline.enabled) {\n            let outline = imesh[\"outline\"].clone();\n            this.atomOutlines.push(outline);\n            outline.name = \"outline\";\n            group.add(outline);\n        }\n        group.position.copy(true_pos);\n        this.atoms.add(group);\n        this.atomFills.push(atom);\n        this.atomNumbers.push(atomicNumber);\n        // Always after adding an atom the bond information should be updated.\n        this.updateBonds = true;\n    }\n    /*\n     * A modified render-function that scales the labels according to the zoom\n     * level.\n     */\n    render() {\n        let canvas = this.rootElement;\n        let canvasWidth = canvas.clientWidth;\n        let canvasHeight = canvas.clientHeight;\n        // Project a [1,0,0] vector in the camera space to the world space, and\n        // then to the screen space. The length of this vector is then used to\n        // scale the labels.\n        let x = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](1, 0, 0);\n        let origin = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, 0, 0);\n        let vectors = [x, origin];\n        for (let i = 0; i < vectors.length; ++i) {\n            let vec = vectors[i];\n            this.camera.localToWorld(vec);\n            vec.project(this.camera);\n            vec.x = Math.round((vec.x + 1) * canvasWidth / 2);\n            vec.y = Math.round((-vec.y + 1) * canvasHeight / 2);\n        }\n        let displacement = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().subVectors(origin, x);\n        let distance = displacement.length();\n        let scale = 8 * 1 / Math.pow(distance, 0.5); // The sqrt makes the scaling behave nicer...\n        if (this.axisLabels !== undefined) {\n            for (let i = 0; i < this.axisLabels.length; ++i) {\n                let label = this.axisLabels[i];\n                label.scale.set(scale, scale, 1);\n            }\n        }\n        super.render();\n    }\n    /**\n     * Used to get a number of repetitions that are needed for the given\n     * latticevector to reach the target size.\n     *\n     * @param latticeVector - The vector that is to be extended.\n     * @param targetSize - The targeted size.\n     */\n    getRepetitions(latticeVector, targetSize) {\n        let vectorLen = latticeVector.length();\n        let multiplier = Math.max(Math.floor(targetSize / vectorLen) - 1, 1);\n        return multiplier;\n    }\n    /**\n     * Setup the view for 0D systems (atoms, molecules).\n     */\n    setup0D(fracPos, cartPos, labels) {\n        let pbc = [false, false, false];\n        this.createConventionalCell(pbc, this.options.cell.enabled);\n        this.createAtoms(fracPos, labels, pbc);\n        this.createLatticeConstants(this.basisVectors, pbc, []);\n    }\n    /**\n     * Replicates the structure along the specified direction to emphasize the\n     * 1D nature of the material.\n     *\n     * @param dim - The index of the periodic dimension.\n     */\n    setup1D(fracPos, cartPos, labels, pbc, periodicIndices) {\n        // Duplicate the cell in the periodic dimensions. The number of\n        // duplications is determined so that a certain size is achieved.\n        let dim = periodicIndices[0];\n        let translation1 = this.basisVectors[dim].clone();\n        let multiplier = this.getRepetitions(translation1, 15);\n        let multipliers = [1, 1, 1];\n        multipliers[dim] = multiplier;\n        this.options.layout.periodicity = multipliers;\n        if (this.options.cell.enabled) {\n            this.createConventionalCell(pbc, this.options.cell.enabled);\n        }\n        this.createAtoms(fracPos, labels, pbc);\n        this.createLatticeConstants(this.basisVectors, pbc, periodicIndices);\n    }\n    /**\n     * Replicates the structure along the specified direction to emphasize the\n     * 2D nature of the material.\n     *\n     * @param periodicIndices - The indices of the periodic dimension.\n     */\n    setup2D(fracPos, cartPos, labels, pbc, periodicIndices) {\n        // Duplicate the cell in the periodic dimensions. The number of\n        // duplications is determined so that a certain size is achieved.\n        let dim1 = periodicIndices[0];\n        let dim2 = periodicIndices[1];\n        let translation1 = this.basisVectors[dim1].clone();\n        let translation2 = this.basisVectors[dim2].clone();\n        let width = 0;\n        let height = 0;\n        if (this.options.layout.allowRepeat) {\n            width = this.getRepetitions(translation1, 12);\n            height = this.getRepetitions(translation2, 12);\n        }\n        let multipliers = [1, 1, 1];\n        multipliers[dim1] = width;\n        multipliers[dim2] = height;\n        this.options.layout.periodicity = multipliers;\n        this.createConventionalCell(pbc, this.options.cell.enabled);\n        this.createAtoms(fracPos, labels, pbc);\n        this.createLatticeConstants(this.basisVectors, pbc, periodicIndices);\n    }\n    /**\n     * Setup the view for 3D systems (crystals)\n     */\n    setup3D(fracPos, cartPos, labels) {\n        let pbc = [true, true, true];\n        this.createConventionalCell(pbc, this.options.cell.enabled);\n        this.createAtoms(fracPos, labels, pbc);\n        this.createLatticeConstants(this.basisVectors, pbc, [0, 1, 2]);\n    }\n}\n\n\n//# sourceURL=webpack://materia/./src/js/structureviewer.js?");

/***/ }),

/***/ "./src/js/viewer.js":
/*!**************************!*\
  !*** ./src/js/viewer.js ***!
  \**************************/
/*! exports provided: Viewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Viewer\", function() { return Viewer; });\n/* harmony import */ var _orthographiccontrols__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./orthographiccontrols */ \"./src/js/orthographiccontrols.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);\n\n\n/**\n * Abstract base class for visualizing 3D scenes with three.js.\n */\nclass Viewer {\n    /**\n     * @param {Object} hostElement is the html element where the\n     *     visualization canvas will be appended.\n     * @param {Object} options An object that can hold custom settings for the viewer.\n     */\n    constructor(hostElement, options = {}) {\n        this.hostElement = hostElement;\n        this.scenes = []; // A list of scenes that are rendered\n        this.cameraWidth = 10.0; // The default \"width\" of the camera\n        this.options = {}; // Options for the viewer. Can be e.g. used to control which settings are enabled\n        this.setOptions(options);\n        this.setupRootElement();\n        this.setupRenderer();\n        this.setupScenes();\n        this.setupStatic();\n        this.setupCamera();\n        this.setupControls();\n        this.changeHostElement(hostElement, false, false);\n        if (this.options.view.autoResize) {\n            window.addEventListener('resize', this.onWindowResize.bind(this), false);\n        }\n    }\n    setOptions(options) {\n        // The default settings object\n        let defaultOptions = {\n            controls: {\n                enableZoom: true,\n                enableRotate: true,\n                enablePan: true,\n                panSpeed: 10,\n                zoomSpeed: 0.2,\n                rotateSpeed: 2.5,\n                zoomLevel: 1,\n            },\n            view: {\n                autoFit: true,\n                autoResize: true,\n                fitMargin: 0.5,\n            },\n            renderer: {\n                backgroundColor: [\"#ffffff\", 0],\n                shadows: {\n                    enabled: false,\n                },\n            }\n        };\n        // Save custom settings\n        this.fillOptions(options, defaultOptions);\n        this.options = defaultOptions;\n    }\n    /**\n     * Used to recursively fill the target options with options stored in the\n     * source object.\n     */\n    fillOptions(source, target) {\n        // Overrride with settings from user and child class\n        function eachRecursive(source, target) {\n            for (var k in source) {\n                // Find variable in default settings\n                if (source[k] !== null && Object.prototype.toString.call(source[k]) === \"[object Object]\") {\n                    // If the current level is not defined in the target, it is\n                    // initialized with empty object.\n                    if (target[k] === undefined) {\n                        target[k] = {};\n                    }\n                    eachRecursive(source[k], target[k]);\n                }\n                else {\n                    // We store each leaf property into the default settings\n                    target[k] = source[k];\n                }\n            }\n        }\n        eachRecursive(source, target);\n    }\n    /**\n     * This function will set up all the basics for visualization: scenes,\n     * lights, camera and controls.\n     */\n    setup() {\n        // Reconstruct the visualization\n        this.setupScenes();\n        this.setupLights();\n        this.setupCamera();\n        this.setupControls();\n    }\n    /**\n     * Loads visuzalization data from a JSON url.\n     *\n     * @param {string} url Path to the json resource.\n     */\n    //loadJSON(url) {\n    //// Open file\n    //var xhr = new XMLHttpRequest();\n    //xhr.onreadystatechange = () => {\n    //this.load(JSON.parse(xhr.responseText))\n    //};\n    //xhr.open(\"GET\", url, true);\n    //xhr.send();\n    //}\n    /**\n     * This function can be used to setup any static assets in the\n     * constructore, like dat.gui settings window.\n     */\n    setupStatic() {\n    }\n    /*\n     * Used to setup the scenes. This default implementation will create a\n     * single scene. Override this function to create additional scenes and\n     * push them all to the 'scenes' attribute.\n     */\n    setupScenes() {\n        this.scenes = [];\n        this.scene = new three__WEBPACK_IMPORTED_MODULE_1__[\"Scene\"]();\n        this.scenes.push(this.scene);\n    }\n    /*\n     * Clears the entire visualization.\n     */\n    clear() {\n        this.clearScenes();\n        this.scenes = null;\n        this.controls = null;\n        this.camera = null;\n        this.cornerPoints = null;\n    }\n    /*\n     * This function will clear everything inside the scenes. This should\n     * ensure that memory is not leaked. Cameras, controls and lights are not\n     * part of the scene, so they are reset elsewhere.\n     */\n    clearScenes() {\n        for (let iScene = 0; iScene < this.scenes.length; ++iScene) {\n            let scene = this.scenes[iScene];\n            scene.traverse(function (node) {\n                let geometry = node.geometry;\n                let material = node.material;\n                let texture = node.texture;\n                if (geometry) {\n                    geometry.dispose();\n                }\n                if (material) {\n                    material.dispose();\n                }\n                if (texture) {\n                    texture.dispose();\n                }\n            });\n            while (scene.children.length) {\n                let child = scene.children[0];\n                scene.remove(child);\n            }\n        }\n    }\n    /**\n     * Can be used to download the current visualization as a jpg-image to the\n     * browser's download location.\n     */\n    takeScreenShot(filename) {\n        let imgData, imgNode;\n        try {\n            // Create headers and actual image contents\n            let strMime = \"image/png\";\n            let strDownloadMime = \"image/octet-stream\";\n            this.render();\n            imgData = this.renderer.domElement.toDataURL(strMime);\n            let strData = imgData.replace(strMime, strDownloadMime);\n            // Create link element for the data. Firefox requires the link to\n            // be in the body\n            filename = filename + \".png\";\n            let link = document.createElement('a');\n            link.style.display = \"none\";\n            document.body.appendChild(link);\n            link.download = filename;\n            link.href = strData;\n            // Force click the link and remove it afterwards.\n            link.click();\n            document.body.removeChild(link);\n        }\n        catch (e) {\n            console.log(e);\n            return;\n        }\n    }\n    /**\n     * This will check if WegGL is available on the current browser.\n     */\n    webglAvailable() {\n        let w = window;\n        try {\n            let canvas = document.createElement('canvas');\n            return !!(w.WebGLRenderingContext && (canvas.getContext('webgl') ||\n                canvas.getContext('experimental-webgl')));\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    /**\n     * This will setup the three.js renderer object. Uses WebGL by default, can\n     * use a canvas fallback is WegGL is not available.\n     */\n    setupRenderer() {\n        // Create the renderer. The \"alpha: true\" enables to set a background color.\n        if (this.webglAvailable()) {\n            this.renderer = new three__WEBPACK_IMPORTED_MODULE_1__[\"WebGLRenderer\"]({\n                alpha: true,\n                antialias: true,\n            });\n        }\n        else {\n            console.log(\"WebGL is not supported on this browser, cannot display structure.\");\n        }\n        let bg = this.options.renderer.backgroundColor;\n        this.renderer.shadowMap.enabled = false;\n        this.renderer.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_1__[\"PCFSoftShadowMap\"];\n        this.renderer.setSize(this.rootElement.clientWidth, this.rootElement.clientHeight);\n        this.renderer.setClearColor(bg[0], bg[1]);\n        this.rootElement.appendChild(this.renderer.domElement);\n        // This is set so that multiple scenes can be used, see\n        // http://stackoverflow.com/questions/12666570/how-to-change-the-zorder-of-object-with-threejs/12666937#12666937\n        this.renderer.autoClear = false;\n    }\n    /**\n     * This will setup the three.js renderer object. Uses WebGL by default, can\n     * use a canvas fallback is WegGL is not available.\n     */\n    setBackgroundColor(color) {\n        // Create the renderer. The \"alpha: true\" enables to set a background color.\n        this.renderer.setClearColor(color[0], color[1]);\n    }\n    /*\n     * Used to setup and position the camera.\n     */\n    setupCamera() {\n        let aspectRatio = this.rootElement.clientWidth / this.rootElement.clientHeight;\n        let width = this.cameraWidth;\n        let height = width / aspectRatio;\n        this.camera = new three__WEBPACK_IMPORTED_MODULE_1__[\"OrthographicCamera\"](width / -2, width / 2, height / 2, height / -2, -100, 1000);\n        this.camera.name = \"camera\";\n        this.camera.position.z = 20;\n    }\n    /**\n     * Used to setup a root DIV element that will contain the whole\n     * visualization, and which will be placed inside the given target element.\n     *\n     * The root element should always fill the whole host element, and we try\n     * to ensure this by setting width and height to 100%. The position is set\n     * to relative, so that the child divs can be set relative to this root div\n     * with absolute positioning.\n     */\n    setupRootElement() {\n        this.rootElement = document.createElement(\"div\");\n        this.rootElement.style.width = \"100%\";\n        this.rootElement.style.height = \"100%\";\n        this.rootElement.style.position = \"relative\";\n    }\n    /**\n     * Used to setup the DOM element where the viewer will be displayed.\n     */\n    changeHostElement(hostElement, refit = true, render = true) {\n        // If no host element currently specified, don't do anything\n        if (hostElement === undefined) {\n            return;\n        }\n        // If a previous target element is set, remove it\n        if (this.hostElement) {\n            while (this.hostElement.firstChild) {\n                this.hostElement.removeChild(this.hostElement.firstChild);\n            }\n        }\n        // Setup the new targetElement\n        hostElement.appendChild(this.rootElement);\n        this.resizeCanvasToHostElement();\n        if (refit) {\n            this.fitToCanvas();\n        }\n        if (render) {\n            this.render();\n        }\n    }\n    /**\n     * Used to reset the original view.\n     */\n    saveReset() {\n        this.controls.saveReset();\n    }\n    /**\n     * Used to reset the original view.\n     */\n    reset() {\n        this.controls.reset();\n    }\n    /*\n     * Used to setup the controls that allow interacting with the visualization\n     * with mouse.\n     */\n    setupControls() {\n        let controls = new _orthographiccontrols__WEBPACK_IMPORTED_MODULE_0__[\"OrthographicControls\"](this.camera, this.rootElement);\n        controls.rotateSpeed = this.options.controls.rotateSpeed;\n        controls.rotationCenter = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]();\n        controls.zoomSpeed = this.options.controls.zoomSpeed;\n        controls.panSpeed = this.options.controls.panSpeed;\n        controls.enableZoom = this.options.controls.enableZoom;\n        controls.enablePan = this.options.controls.enablePan;\n        controls.enableRotate = this.options.controls.enableRotate;\n        controls.staticMoving = true;\n        controls.dynamicDampingFactor = 0.25;\n        controls.keys = [65, 83, 68];\n        controls.addEventListener('change', this.render.bind(this));\n        this.controls = controls;\n    }\n    /**\n     * Creates 8 corner points for the given cuboid.\n     *\n     * @param origin - The origin of the cuboid.\n     * @param basis - The vectors that define the cuboid.\n     */\n    createCornerPoints(origin, basis) {\n        var geometry = new three__WEBPACK_IMPORTED_MODULE_1__[\"Geometry\"]();\n        geometry.vertices.push(origin);\n        let opposite = origin.clone().add(basis[0]).add(basis[1]).add(basis[2]);\n        geometry.vertices.push(opposite);\n        for (let len = basis.length, i = 0; i < len; ++i) {\n            // Corners close to origin\n            let position1 = origin.clone().add(basis[i].clone());\n            geometry.vertices.push(position1);\n            // Corners close to opposite point of origin\n            let position2 = opposite.clone().sub(basis[i].clone());\n            geometry.vertices.push(position2);\n        }\n        return geometry;\n    }\n    /**\n     * This will automatically fit the structure to the given rendering area.\n     * Will also leave a small margin.\n     */\n    fitToCanvas() {\n        // If cornerpoints have not yet been defined, do nothing\n        if (this.cornerPoints === undefined) {\n            return;\n        }\n        // Make sure that all transforms are updated\n        this.scenes.forEach((scene) => scene.updateMatrixWorld());\n        // Project all 8 corners of the normalized cell into screen space and\n        // see how the system should be scaled to fit into screen\n        let canvas = this.rootElement;\n        let canvasWidth = canvas.clientWidth;\n        let canvasHeight = canvas.clientHeight;\n        let cornerPos = [];\n        //console.log(canvas.clientWidth)\n        //console.log(canvas.clientHeight)\n        // Figure out the center in order to add margins in right direction\n        let centerPos = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]();\n        for (let len = this.cornerPoints.geometry.vertices.length, i = 0; i < len; ++i) {\n            let screenPos = this.cornerPoints.geometry.vertices[i].clone();\n            this.cornerPoints.localToWorld(screenPos);\n            centerPos.add(screenPos);\n        }\n        for (let len = this.cornerPoints.geometry.vertices.length, i = 0; i < len; ++i) {\n            let screenPos = this.cornerPoints.geometry.vertices[i].clone();\n            //console.log(screenPos)\n            this.cornerPoints.localToWorld(screenPos);\n            // Default the zoom to 1 for the projection\n            let oldZoom = this.camera.zoom;\n            this.camera.zoom = this.options.controls.zoomLevel;\n            this.camera.updateProjectionMatrix();\n            // Figure out the direction from center\n            let diff = centerPos.sub(screenPos);\n            diff.project(this.camera);\n            let right = diff.x < 0 ? true : false;\n            let up = diff.y < 0 ? true : false;\n            // Map to corner coordinates to\n            screenPos.project(this.camera);\n            //console.log(screenPos)\n            // Add a margin\n            let margin = this.options.view.fitMargin;\n            let cameraUp = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0, margin, 0);\n            let cameraRight = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](margin, 0, 0);\n            cameraUp.applyQuaternion(this.camera.quaternion);\n            cameraRight.applyQuaternion(this.camera.quaternion);\n            if (up) {\n                screenPos.add(cameraUp);\n            }\n            else {\n                screenPos.sub(cameraUp);\n            }\n            if (right) {\n                screenPos.add(cameraRight);\n            }\n            else {\n                screenPos.sub(cameraRight);\n            }\n            // Map to 2D screen space\n            screenPos.x = Math.round((screenPos.x + 1) * canvasWidth / 2);\n            screenPos.y = Math.round((-screenPos.y + 1) * canvasHeight / 2);\n            screenPos.z = 0;\n            cornerPos.push(screenPos);\n        }\n        // Find the minimum and maximum in both screen dimensions\n        let minX = cornerPos[0].x;\n        let maxX = cornerPos[0].x;\n        let minY = cornerPos[0].y;\n        let maxY = cornerPos[0].y;\n        for (let len = cornerPos.length, i = 0; i < len; ++i) {\n            let pos = cornerPos[i];\n            let x = pos.x;\n            let y = pos.y;\n            if (x > maxX) {\n                maxX = x;\n            }\n            else if (x < minX) {\n                minX = x;\n            }\n            if (y > maxY) {\n                maxY = y;\n            }\n            else if (y < minY) {\n                minY = y;\n            }\n        }\n        // Determine new zoom that will ensure that all cornerpositions are\n        // visible on screen, assuming that the zoom center is set to view\n        // center.\n        let centerX = (canvasWidth / 2);\n        let centerY = (canvasHeight / 2);\n        let zoomRight = centerX / Math.abs(maxX - centerX);\n        let zoomLeft = centerX / Math.abs(minX - centerX);\n        let zoomUp = centerY / Math.abs(minY - centerY);\n        let zoomDown = centerY / Math.abs(maxY - centerY);\n        let newZoom = Math.min(zoomRight, zoomLeft, zoomUp, zoomDown);\n        this.camera.zoom = newZoom;\n        this.camera.updateProjectionMatrix();\n    }\n    /*\n     * Get the current zoom level for the visualization.\n     */\n    getZoom() {\n        return this.camera.zoom;\n    }\n    /**\n     * Sets the zoom level for the visualization.\n     *\n     * @param zoom - The wanted zoom level as a floating point number.\n     */\n    setZoom(zoom) {\n        this.camera.zoom = zoom;\n        this.camera.updateProjectionMatrix();\n    }\n    /*\n     * Callback function that is invoked when the window is resized.\n     */\n    resizeCanvasToHostElement() {\n        let aspectRatio = this.rootElement.clientWidth / this.rootElement.clientHeight;\n        let width = this.cameraWidth;\n        let height = width / aspectRatio;\n        this.camera.left = -width / 2;\n        this.camera.right = width / 2;\n        this.camera.top = height / 2;\n        this.camera.bottom = -height / 2;\n        this.camera.updateProjectionMatrix();\n        this.renderer.setSize(this.rootElement.clientWidth, this.rootElement.clientHeight);\n        this.controls.handleResize();\n        this.render();\n    }\n    onWindowResize() {\n        this.resizeCanvasToHostElement();\n        if (this.options.view.autoFit) {\n            this.fitToCanvas();\n        }\n        this.render();\n    }\n    /*\n     * Used to render all the scenes that are present. The scenes will be\n     * rendered on top of each other, so make sure that they are in the right\n     * order.\n     *\n     * This approach is copied from\n     * http://stackoverflow.com/questions/12666570/how-to-change-the-zorder-of-object-with-threejs/12666937#12666937\n     */\n    render() {\n        this.renderer.clear();\n        for (let iScene = 0; iScene < this.scenes.length; ++iScene) {\n            let scene = this.scenes[iScene];\n            this.renderer.render(scene, this.camera);\n            if (iScene !== this.scenes.length - 1) {\n                this.renderer.clearDepth();\n            }\n        }\n    }\n    /**\n     * Helper function for creating a cylinder mesh.\n     *\n     * @param pos1 - Start position\n     * @param pos2 - End position\n     * @param radius - Cylinder radius\n     * @param material - Cylinder material\n     */\n    createCylinder(pos1, pos2, radius, nSegments, material) {\n        var direction = new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().subVectors(pos2, pos1);\n        let dirLen = direction.length();\n        let dirNorm = direction.clone().divideScalar(dirLen);\n        var arrow = new three__WEBPACK_IMPORTED_MODULE_1__[\"ArrowHelper\"](dirNorm, pos1);\n        var edgeGeometry = new three__WEBPACK_IMPORTED_MODULE_1__[\"CylinderGeometry\"](radius, radius, dirLen, nSegments, 0);\n        var edge = new three__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"](edgeGeometry, material);\n        edge.rotation.copy(arrow.rotation.clone());\n        edge.position.copy(new three__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]().addVectors(pos1, direction.multiplyScalar(0.5)));\n        return edge;\n    }\n    /**\n     * Rotate an object around an arbitrary axis in world space\n     * @param obj - The THREE.Object3D to rotate\n     * @param axis - The axis in world space\n     * @param radians - The angle in radians\n     */\n    rotateAroundWorldAxis(obj, axis, radians) {\n        let rotWorldMatrix = new three__WEBPACK_IMPORTED_MODULE_1__[\"Matrix4\"]();\n        rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);\n        rotWorldMatrix.multiply(obj.matrix); // pre-multiply\n        obj.matrix = rotWorldMatrix;\n        obj.rotation.setFromRotationMatrix(obj.matrix);\n    }\n}\n\n\n//# sourceURL=webpack://materia/./src/js/viewer.js?");

/***/ }),

/***/ 0:
/*!*********************************!*\
  !*** multi ./src/js/materia.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/js/materia.js */\"./src/js/materia.js\");\n\n\n//# sourceURL=webpack://materia/multi_./src/js/materia.js?");

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = THREE;\n\n//# sourceURL=webpack://materia/external_%22THREE%22?");

/***/ })

/******/ });